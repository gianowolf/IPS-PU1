[
  {
    "objectID": "notebooks/ejercicio1/02_h_system.html",
    "href": "notebooks/ejercicio1/02_h_system.html",
    "title": "Sistemas",
    "section": "",
    "text": "Dados los sistemas $ S1, S2, S3, S4 $ se procede a encontrar de forma analitica su respuesta impulsional y su respuesta en frecuencia.",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/02_h_system.html#sistema-s1",
    "href": "notebooks/ejercicio1/02_h_system.html#sistema-s1",
    "title": "Sistemas",
    "section": "Sistema S1",
    "text": "Sistema S1\nLa ecuación en diferencias del sistema 1 es:\n\\[\ny[n] = \\frac{1}{2}x[n] + \\frac{1}{2}x[n-1].\n\\]\nLa respuesta impulsional se obtiene aplicando un impulso unitario $ x[n] = $ como entrada. Por definición:\n\\[\n\\delta[n] =\n\\begin{cases}\n1 & \\text{si } n = 0, \\\\\n0 & \\text{si } n \\neq 0.\n\\end{cases}\n\\]\nSustituyendo $ x[n] = $ en la ecuación:\n\\[\nh[n] = \\frac{1}{2}\\delta[n] + \\frac{1}{2}\\delta[n-1].\n\\]\nEsto implica que $ h[n] $ es la suma de dos impulsos desplazados:\n- Un impulso en $ n = 0 $ con coeficiente $ $.\n- Un impulso en $ n = 1 $ con coeficiente $ $.\nPor lo tanto, la respuesta impulsional $ h[n] $ es:\n\\[\nh[n] =\n\\begin{cases}\n\\frac{1}{2} & \\text{si } n = 0, \\\\\n\\frac{1}{2} & \\text{si } n = 1, \\\\\n0 & \\text{en otro caso}.\n\\end{cases}\n\\]\nLa respuesta en frecuencia se obtiene aplicando la Transformada de Fourier en Tiempo Discreto (TFTD) a $ h[n] $. La definición de la TFTD es:\n\\[\nH(e^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} h[n] e^{-j\\omega n}.\n\\]\nDado que $ h[n] $ tiene valores distintos de cero solo en $ n = 0 $ y $ n = 1 $, sustituimos estos valores en la definición:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2}e^{-j\\omega \\cdot 0} + \\frac{1}{2}e^{-j\\omega \\cdot 1}.\n\\]\nSimplificamos los términos exponenciales:\n- $ e^{-j} = 1 $.\n- $ e^{-j} = e^{-j} $.\nPor lo tanto:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2} \\left( 1 + e^{-j\\omega} \\right).\n\\]\nel modulo de $ H(e^{j}) $ se calcula como:\n\\[\n|H(e^{j\\omega})| = \\sqrt{\\text{Re}(H)^2 + \\text{Im}(H)^2}.\n\\]\nSustituyendo $ H(e^{j}) $:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2} \\left( 1 + e^{-j\\omega} \\right).\n\\]\nSabemos que $ e^{-j} $ se puede descomponer como $ () - j() $. Por lo tanto:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2} \\left( 1 + \\cos(\\omega) - j\\sin(\\omega) \\right).\n\\]\nLa parte real y la parte imaginaria son:\n- Parte real: $ (H) = (1 + ()) $.\n- Parte imaginaria: $ (H) = -() $.\nLa magnitud es entonces:\n\\[\n|H(e^{j\\omega})| = \\frac{1}{2} \\sqrt{(1 + \\cos(\\omega))^2 + \\sin^2(\\omega)}.\n\\]\nSimplificamos utilizando la identidad trigonométrica $ ^2() + ^2() = 1 $:\n\\[\n|H(e^{j\\omega})| = \\frac{1}{2} \\sqrt{1 + 2\\cos(\\omega) + 1}.\n\\]\nSimplificando aún más:\n\\[\n|H(e^{j\\omega})| = \\sqrt{\\frac{1 + \\cos(\\omega)}{2}}.\n\\]\nLa fase de $ H(e^{j}) $ se calcula como:\n\\[\n\\angle H(e^{j\\omega}) = \\arctan\\left( \\frac{\\text{Im}(H)}{\\text{Re}(H)} \\right).\n\\]\nSustituyendo los valores de la parte real e imaginaria:\n\\[\n\\angle H(e^{j\\omega}) = \\arctan\\left( \\frac{-\\sin(\\omega)}{1 + \\cos(\\omega)} \\right).\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Respuesta impulsional h[n] - Sistema 1\nn = np.arange(0, 10)  # Instantes de tiempo\nh = np.zeros_like(n, dtype=float)\nh[0] = 0.5  # Valor en n = 0\nh[1] = 0.5  # Valor en n = 1\n\n# Respuesta en frecuencia H(e^jw)\nomega = np.linspace(-np.pi, np.pi, 1000)  # Frecuencias normalizadas\nH = 0.5 * (1 + np.exp(-1j * omega))  # Respuesta en frecuencia\n\n# Calcular magnitud y fase\nmagnitude = np.abs(H)\nphase = np.angle(H)\n\n# Graficar la respuesta impulsional\nplt.figure(figsize=(12, 8))\n\nplt.subplot(3, 1, 1)\nplt.stem(n, h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 1\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Graficar la magnitud de la respuesta en frecuencia\nplt.subplot(3, 1, 2)\nplt.plot(omega, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Graficar la fase de la respuesta en frecuencia\nplt.subplot(3, 1, 3)\nplt.plot(omega, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/02_h_system.html#sistema-2",
    "href": "notebooks/ejercicio1/02_h_system.html#sistema-2",
    "title": "Sistemas",
    "section": "Sistema 2",
    "text": "Sistema 2\nLa ecuación de diferencias del Sistema 2 es:\n\\[\ny[n] = \\frac{1}{2}x[n] - \\frac{1}{2}x[n-1].\n\\]\nLa salida del sistema cuando la entrada es $ x[n] = $:\n\\[\nh[n] = \\frac{1}{2}\\delta[n] - \\frac{1}{2}\\delta[n-1].\n\\]\nLa Transformada de Fourier de $ h[n] $ es:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2}(1 - e^{-j\\omega}).\n\\]\nSustituyendo $ e^{-j} = () - j() $, obtenemos:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2} \\left( 1 - \\cos(\\omega) + j\\sin(\\omega) \\right).\n\\]\nModulo:\n\\[\n|H(e^{j\\omega})| = \\sqrt{\\frac{1 - \\cos(\\omega)}{2}}.\n\\]\nFase:\n\\[\n\\angle H(e^{j\\omega}) = \\arctan\\left( \\frac{\\sin(\\omega)}{1 - \\cos(\\omega)} \\right).\n\\]\n\n# Respuesta impulsional h[n] - Sistema 2\nn = np.arange(0, 10)  # Instantes de tiempo\nh = np.zeros_like(n, dtype=float)\nh[0] = 0.5  # Valor en n = 0\nh[1] = -0.5 # Valor en n = 1\n\n# Respuesta en frecuencia H(e^jw)\nomega = np.linspace(-np.pi, np.pi, 1000)  # Frecuencias normalizadas\nH = 0.5 * (1 - np.exp(-1j * omega))  # Respuesta en frecuencia\n\n# Calcular magnitud y fase\nmagnitude = np.abs(H)\nphase = np.angle(H)\n\n# Graficar la respuesta impulsional\nplt.figure(figsize=(12, 8))\n\nplt.subplot(3, 1, 1)\nplt.stem(n, h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 2\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Graficar la magnitud de la respuesta en frecuencia\nplt.subplot(3, 1, 2)\nplt.plot(omega, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Graficar la fase de la respuesta en frecuencia\nplt.subplot(3, 1, 3)\nplt.plot(omega, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nResolución Analítica del Sistema 3\nLa ecuación de diferencias del Sistema 3 es:\n\\[\ny[n] = \\frac{1}{4}x[n] + \\frac{1}{4}x[n-1] + \\frac{1}{2}y[n-1].\n\\]\nLa salida del sistema $ y[n] $ cuando la entrada es $ x[n] = $ se obtiene resolviendo la ecuación en diferencias de manera recursiva.\nInicialmente, suponemos que $ y[n] = h[n] $ y que:\n- $ x[n] = $: el impulso unitario.\n- $ y[n] = 0 $ para $ n &lt; 0 $ (condición inicial).\nSustituyendo $ x[n] = $ en la ecuación:\nPara $ n = 0 \\(:\\)$ h[0] = + + h[-1]. \\[  \nDado que $ \\delta[0] = 1 $, $ \\delta[-1] = 0 $, y $ h[-1] = 0 $:  \n\\] h[0] = . $$\nPara $ n = 1 \\(:\\)$ h[1] = + + h[0]. \\[  \nSustituyendo $ \\delta[1] = 0 $, $ \\delta[0] = 1 $, y $ h[0] = \\frac{1}{4} $:  \n\\] h[1] = + = + = . $$\nPara $ n = 2 \\(:\\)$ h[2] = + + h[1]. \\[  \nSustituyendo $ \\delta[2] = 0 $, $ \\delta[1] = 0 $, y $ h[1] = \\frac{3}{8} $:  \n\\] h[2] = = . $$\nDe manera general, la respuesta impulsional $ h[n] $ es una secuencia exponencial decreciente, debido al término recursivo $ y[n-1] $.\nLa respuesta en frecuencia\n\\[\nH(e^{j\\omega}) = \\frac{B(e^{j\\omega})}{A(e^{j\\omega})},\n\\]\ndonde:\n- $ B(e^{j}) $ es el polinomio del numerador correspondiente a $ x[n] $.\n- $ A(e^{j}) $ es el polinomio del denominador correspondiente a $ y[n] $.\nLos coeficientes son:\n- Numerador: $ B(z) = + z^{-1} $.\n- Denominador: $ A(z) = 1 - z^{-1} $.\nPor lo tanto:\n\\[\nH(e^{j\\omega}) = \\frac{\\frac{1}{4} + \\frac{1}{4}e^{-j\\omega}}{1 - \\frac{1}{2}e^{-j\\omega}}.\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Respuesta impulsional h[n] - Sistema 3 (exponencial decreciente)\nn = np.arange(0, 10)  # Instantes de tiempo\nh = (1 / 4) * (1 / 2) ** n  # Respuesta impulsional analítica\n\n# Respuesta en frecuencia H(e^jw)\nomega = np.linspace(-np.pi, np.pi, 1000)  # Frecuencias normalizadas\nnumerator = 0.25 + 0.25 * np.exp(-1j * omega)  # Numerador\ndenominator = 1 - 0.5 * np.exp(-1j * omega)  # Denominador\nH = numerator / denominator  # Respuesta en frecuencia\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H)  # Magnitud de H(e^jw)\nphase = np.angle(H)    # Fase de H(e^jw)\n\n# Graficar la respuesta impulsional\nplt.figure(figsize=(12, 8))\n\nplt.subplot(3, 1, 1)\nplt.stem(n, h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 3\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Graficar la magnitud de la respuesta en frecuencia\nplt.subplot(3, 1, 2)\nplt.plot(omega, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Graficar la fase de la respuesta en frecuencia\nplt.subplot(3, 1, 3)\nplt.plot(omega, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nSistema 4\nLa ecuación en diferencias del Sistema 4 es:\n\\[\ny[n] = \\frac{1}{4}x[n] - \\frac{1}{4}x[n-1] - \\frac{1}{2}y[n-1].\n\\]\nPara obtener la respuesta impulsional $ h[n] $, aplicamos como entrada el impulso unitario $ x[n] = $. La ecuación en diferencias se resuelve de forma recursiva:\nCondiciones iniciales: - $ x[n] = $ para $ n = 0 $.\n- $ h[n] = 0 $ para $ n &lt; 0 $.\n\nPara $ n = 0 $:\n\n\\[\nh[0] = \\frac{1}{4}\\delta[0] - \\frac{1}{4}\\delta[-1] - \\frac{1}{2}h[-1].\n\\]\nSustituyendo $ = 1 $, $ = 0 $, y $ h[-1] = 0 $:\n\\[\nh[0] = \\frac{1}{4}.\n\\]\n\nPara $ n = 1 $:\n\n\\[\nh[1] = \\frac{1}{4}\\delta[1] - \\frac{1}{4}\\delta[0] - \\frac{1}{2}h[0].\n\\]\nSustituyendo $ = 0 $, $ = 1 $, y $ h[0] = $:\n\\[\nh[1] = -\\frac{1}{4} - \\frac{1}{2} \\cdot \\frac{1}{4} = -\\frac{1}{4} - \\frac{1}{8} = -\\frac{3}{8}.\n\\]\n\nPara $ n = 2 $:\n\n\\[\nh[2] = \\frac{1}{4}\\delta[2] - \\frac{1}{4}\\delta[1] - \\frac{1}{2}h[1].\n\\]\nSustituyendo $ = 0 $, $ = 0 $, y $ h[1] = - $:\n\\[\nh[2] = -\\frac{1}{2} \\cdot \\left( -\\frac{3}{8} \\right) = \\frac{3}{16}.\n\\]\nLa secuencia resultante es una exponencial alternada decreciente debido al término negativo recursivo $ -y[n-1] $.\nGeneralización:\n\\[\nh[n] = \\frac{1}{4} \\left( -\\frac{1}{2} \\right)^n, \\; n \\geq 0.\n\\]\nAplicamos la Transformada de Fourier en Tiempo Discreto (TFTD) a la ecuación en diferencias. La respuesta en frecuencia se calcula como:\n\\[\nH(e^{j\\omega}) = \\frac{B(e^{j\\omega})}{A(e^{j\\omega})}.\n\\]\nDonde:\n- El numerador es $ B(z) = - z^{-1} $.\n- El denominador es $ A(z) = 1 + z^{-1} $.\nSustituyendo $ z = e^{j} $, obtenemos:\n\\[\nH(e^{j\\omega}) = \\frac{\\frac{1}{4} - \\frac{1}{4}e^{-j\\omega}}{1 + \\frac{1}{2}e^{-j\\omega}}.\n\\]\n\nMagnitud de $ H(e^{j}) $:\n\n\\[\n|H(e^{j\\omega})| = \\frac{\\left| \\frac{1}{4} - \\frac{1}{4}e^{-j\\omega} \\right|}{\\left| 1 + \\frac{1}{2}e^{-j\\omega} \\right|}.\n\\]\n\nFase de $ H(e^{j}) $:\n\n\\[\n\\angle H(e^{j\\omega}) = \\angle \\left( \\frac{\\frac{1}{4} - \\frac{1}{4}e^{-j\\omega}}{1 + \\frac{1}{2}e^{-j\\omega}} \\right).\n\\]\n\n# Respuesta impulsional h[n] - Sistema 4 (exponencial alternada decreciente)\nn = np.arange(0, 10)  # Instantes de tiempo\nh = (1 / 4) * (-1 / 2) ** n  # Respuesta impulsional analítica\n\n# Respuesta en frecuencia H(e^jw)\nomega = np.linspace(-np.pi, np.pi, 1000)  # Frecuencias normalizadas\nnumerator = 0.25 - 0.25 * np.exp(-1j * omega)  # Numerador\ndenominator = 1 + 0.5 * np.exp(-1j * omega)    # Denominador\nH = numerator / denominator  # Respuesta en frecuencia\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H)\nphase = np.angle(H)\n\n# Graficar la respuesta impulsional\nplt.figure(figsize=(12, 8))\n\nplt.subplot(3, 1, 1)\nplt.stem(n, h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 4\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Graficar la magnitud de la respuesta en frecuencia\nplt.subplot(3, 1, 2)\nplt.plot(omega, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Graficar la fase de la respuesta en frecuencia\nplt.subplot(3, 1, 3)\nplt.plot(omega, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/04_y_output.html",
    "href": "notebooks/ejercicio1/04_y_output.html",
    "title": "Carga senal de entrada $ x[n] $",
    "section": "",
    "text": "Como se realizó anteriormente, se selecciona una senal de entrada en base al numero de alumno, mediante la función load_signal\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función para cargar la señal desde el archivo CSV\ndef load_signal(case_number, base_path=\"data/signals\"):\n    \"\"\"\n    Carga una señal desde un archivo CSV según el número de caso.\n\n    Parámetros:\n        case_number (int): Número de caso (0, 1, 2, 3).\n        base_path (str): Ruta base donde se encuentran los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes n (0 hasta longitud de la señal - 1).\n        x (numpy.ndarray): Valores de la señal x[n].\n    \"\"\"\n    # Construir la ruta del archivo CSV\n    file_path = os.path.join(base_path, f\"case{case_number}.csv\")\n    \n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n    \n    # Cargar los valores de la señal desde el archivo CSV\n    x = np.loadtxt(file_path, delimiter=\",\")\n    \n    # Generar los instantes n (0, 1, ..., len(x)-1)\n    n = np.arange(len(x))\n    \n    return n, x",
    "crumbs": [
      "Ejercicio 1",
      "Carga senal de entrada $ x[n] $"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/04_y_output.html#se-definen-los-sistemas",
    "href": "notebooks/ejercicio1/04_y_output.html#se-definen-los-sistemas",
    "title": "Carga senal de entrada $ x[n] $",
    "section": "Se definen los sistemas",
    "text": "Se definen los sistemas\nSe definen los sistemas como funciones.\n\nN es la longitud de la senal de entrada.\nse inicializa la salida y con ceros.\nse realiza una convolucion de forma iterativa\n\n\n# Definir las implementaciones de los sistemas (previamente implementados)\ndef sistema1(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.5 * x[n]\n        if n &gt; 0:\n            y[n] += 0.5 * x[n-1]\n    return y\n\ndef sistema2(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.5 * x[n]\n        if n &gt; 0:\n            y[n] -= 0.5 * x[n-1]\n    return y\n\ndef sistema3(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.25 * x[n]\n        if n &gt; 0:\n            y[n] += 0.25 * x[n-1]\n            y[n] += 0.5 * y[n-1]\n    return y\n\ndef sistema4(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.25 * x[n]\n        if n &gt; 0:\n            y[n] -= 0.25 * x[n-1]\n            y[n] -= 0.5 * y[n-1]\n    return y",
    "crumbs": [
      "Ejercicio 1",
      "Carga senal de entrada $ x[n] $"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/04_y_output.html#se-aplica-la-entrada-al-sistema",
    "href": "notebooks/ejercicio1/04_y_output.html#se-aplica-la-entrada-al-sistema",
    "title": "Carga senal de entrada $ x[n] $",
    "section": "Se aplica la entrada al sistema",
    "text": "Se aplica la entrada al sistema\nSe aplica la entrada $ x[n] $ en cada uno de los sistemas, y se grafican\n\n# Número de alumno y selección de caso\nnum_al = 14253  # Número de alumno\ncase_number = num_al % 4  # Determinar el número de caso\nprint(f\"El número de caso seleccionado es: {case_number}\")\n\n# Cargar la señal correspondiente\nn, x = load_signal(case_number)\n\n# Aplicar los sistemas a la señal de entrada\ny1 = sistema1(x)\ny2 = sistema2(x)\ny3 = sistema3(x)\ny4 = sistema4(x)\n\n# Graficar las señales de salida\nplt.figure(figsize=(12, 10))\n\n# Señal de entrada\nplt.subplot(5, 1, 1)\nplt.stem(n, x, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(f\"Señal de Entrada x[n] - Caso {case_number} para Número de Alumno {num_al}\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"x[n]\")\nplt.grid()\n\n# Salida del Sistema 1\nplt.subplot(5, 1, 2)\nplt.stem(n, y1, basefmt=\" \", linefmt=\"g-\", markerfmt=\"go\")\nplt.title(\"Salida del Sistema 1\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y1[n]\")\nplt.grid()\n\n# Salida del Sistema 2\nplt.subplot(5, 1, 3)\nplt.stem(n, y2, basefmt=\" \", linefmt=\"r-\", markerfmt=\"ro\")\nplt.title(\"Salida del Sistema 2\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y2[n]\")\nplt.grid()\n\n# Salida del Sistema 3\nplt.subplot(5, 1, 4)\nplt.stem(n, y3, basefmt=\" \", linefmt=\"c-\", markerfmt=\"co\")\nplt.title(\"Salida del Sistema 3\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y3[n]\")\nplt.grid()\n\n# Salida del Sistema 4\nplt.subplot(5, 1, 5)\nplt.stem(n, y4, basefmt=\" \", linefmt=\"m-\", markerfmt=\"mo\")\nplt.title(\"Salida del Sistema 4\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y4[n]\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\nEl número de caso seleccionado es: 1\n\n\n\n\n\n\n\n\n\n\nConclusiones de las salidas\n\nSistema 1\nEl Sistema 1 es un filtro pasa bajas, de promedio movil de orden 1.\nLa salida obtenida suaviza la señal de entrada. Se observa el patron de crecimiento de la señal de entrada, pero menos oscilante. Esto se debe a que el valor de $ y[n] $ es el promedio ponderado de x[n] y x[n-1], lo cual atenua frecuencias altas.\n\n\nSistema 2\nEl Sistema 2 es un filtro pasa altas. La salida resalta los cambios bruscos de la senal de entrada. Aqui destaca la baja amplitud de la salida, en comparacion con los valores de entrada. Esto se debe a la diferencia entre valores consecutivos de $ x[n] $.\n\n\nSistema 3\nEl Sistema 3 es un filtro pasa bajas recursivo (con termino de retroalimentacion). Al igual que el Sistema 1, suaviza la senal de entrada.\n\n\nSistema 4\nEl Sistema 4 es un filtro pasa altas recursivo, con retroalimentacion negativa. Amplifica los cambios rapidos e introduce el efecto de alternancia.",
    "crumbs": [
      "Ejercicio 1",
      "Carga senal de entrada $ x[n] $"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/04_y_output.html#se-obtiene-la-tftd-de-las-salidas",
    "href": "notebooks/ejercicio1/04_y_output.html#se-obtiene-la-tftd-de-las-salidas",
    "title": "Carga senal de entrada $ x[n] $",
    "section": "Se obtiene la TFTD de las salidas",
    "text": "Se obtiene la TFTD de las salidas\nPara realizar un analisis del comportamiento de las frecuencias al aplicar los distintos sistemas, se aplica la TFTD a las salidas.\n\n# Calcular la TFTD de la señal de entrada x[n]\nfft_x = np.fft.fft(x, n=512)  # FFT con cero-padding hasta 512 puntos\nfft_x_shifted = np.fft.fftshift(fft_x)  # Desplazar para centrar en ω = 0\n\n# Calcular la TFTD de las salidas\nfft_y1 = np.fft.fft(y1, n=512)\nfft_y2 = np.fft.fft(y2, n=512)\nfft_y3 = np.fft.fft(y3, n=512)\nfft_y4 = np.fft.fft(y4, n=512)\n\n# Frecuencias normalizadas\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Rango de -π a π\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Desplazar las FFT para centrar en ω = 0\nfft_y1_shifted = np.fft.fftshift(fft_y1)\nfft_y2_shifted = np.fft.fftshift(fft_y2)\nfft_y3_shifted = np.fft.fftshift(fft_y3)\nfft_y4_shifted = np.fft.fftshift(fft_y4)\n\n# Graficar las respuestas en frecuencia\nplt.figure(figsize=(12, 12))\n\n# Magnitud de la TFTD - Señal de Entrada\nplt.subplot(5, 1, 1)\nplt.plot(frequencies_shifted, np.abs(fft_x_shifted), color='k')\nplt.title(\"TFTD: Magnitud de la Señal de Entrada $x[n]$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|X(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 1\nplt.subplot(5, 1, 2)\nplt.plot(frequencies_shifted, np.abs(fft_y1_shifted), color='b')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 1\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_1(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 2\nplt.subplot(5, 1, 3)\nplt.plot(frequencies_shifted, np.abs(fft_y2_shifted), color='g')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 2\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_2(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 3\nplt.subplot(5, 1, 4)\nplt.plot(frequencies_shifted, np.abs(fft_y3_shifted), color='r')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 3\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_3(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 4\nplt.subplot(5, 1, 5)\nplt.plot(frequencies_shifted, np.abs(fft_y4_shifted), color='m')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 4\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_4(e^{j\\omega})|$\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nEl primer grafico muestra el modulo de la TFTD de la senal de entrada $ x[n] $. Se observa un pico predominante en bajas frecuencias (cerca de $ = 0 $), lo cual indica que la senal tiene componentes de baja frecuencia elevadas.\nAdemas, se notan componentes de alta frecuencia cerca de $ $. Aunque la magnitud de estas frecuencias es mucho menor a las cercanas a cero, se observa un crecimiento notorio a medida que las frecuencias aumentan.\nLos Sistemas 1 y 3, mantienen el pico centrado en $ = 0 $ similar a la senal de entrada. Y en contraste con esta, las frecuencias altas han sido atenuadas, como se espera en filtros pasa bajos.\nLos Sistemas 2 y 4, en cambio, funcionan como filtros pasa altos y se observa que las frecuencias bajas, predominantes en la senal de entrada, se encuentran atenuadas casi por completo, y mantiene las frecuencias altas, que se pueden apreciar mejor en estos graficos debido al reescalado del eje de magnitud.",
    "crumbs": [
      "Ejercicio 1",
      "Carga senal de entrada $ x[n] $"
    ]
  },
  {
    "objectID": "notebooks/ejercicio2/01_h_system.html",
    "href": "notebooks/ejercicio2/01_h_system.html",
    "title": "hcanald.py",
    "section": "",
    "text": "import numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\ndef load_hcanal(num_al, base_path=\"data/signals\"):\n    \"\"\"\n    Selecciona y carga la respuesta impulsional del canal discreto desde el archivo CSV.\n\n    Parámetros:\n        num_al (int): Número de alumno.\n        base_path (str): Ruta base donde se encuentran los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes n correspondientes a la respuesta impulsional.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n    \"\"\"\n    # Determinar el número de caso (num_al % 5)\n    case_number = num_al % 5\n    print(f\"El número de caso seleccionado es: {case_number}\")\n\n    # Construir la ruta del archivo CSV\n    file_name = f\"case{case_number}_clean.csv\"\n    file_path = os.path.join(base_path, file_name)\n\n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe. Verifique la ruta.\")\n\n    # Generar los instantes n (valores reales)\n    h = np.loadtxt(file_path, delimiter=\",\")\n    n = np.arange(len(h))  # Índices reales de n en base a la longitud de h\n\n    return n, h\n\ndef plot_sparse_signal(n, h):\n    \"\"\"\n    Grafica una señal mostrando solo los valores no nulos y usando puntos suspensivos.\n\n    Parámetros:\n        n (numpy.ndarray): Instantes de tiempo (valores reales del CSV).\n        h (numpy.ndarray): Respuesta impulsional (amplitud de la señal).\n    \"\"\"\n    # Encontrar los índices donde h es no nulo\n    non_zero_indices = np.nonzero(h)[0]\n    \n    plt.figure(figsize=(12, 5))\n    \n    # Inicializar el gráfico\n    last_index = -1  # Para manejar el primer tramo de ceros\n    for idx in non_zero_indices:\n        # Dibujar un tramo de ceros con puntos suspensivos si hay una separación grande\n        if last_index != -1 and (n[idx] &gt; n[last_index] + 1):\n            mid_point = (n[last_index] + n[idx]) / 2\n            plt.text(mid_point, 0, '...', ha='center', va='center', fontsize=34, fontweight='bold', color='blue')\n\n        # Dibujar el valor no nulo\n        plt.stem([n[idx]], [h[idx]], linefmt=\"b-\", markerfmt=\"bo\", basefmt=\" \")\n\n        # Actualizar el último índice no nulo\n        last_index = idx\n\n    # Configuración del gráfico\n    plt.title(\"Respuesta Impulsional del Canal (Valores No Nulos Resaltados)\")\n    plt.xlabel(\"n (instantes)\")\n    plt.ylabel(\"h[n] (amplitud)\")\n    plt.grid()\n    plt.show()\n\n# Número de alumno de entrada\nnum_al = 14253\n\n# Seleccionar y cargar la respuesta impulsional\nn, h = load_hcanal(num_al)\n \n# Mostrar información básica\nprint(f\"Longitud de la respuesta impulsional: {len(h)}\")\nprint(f\"Primeros 10 valores de h: {h[:10]}\")\n\n# Graficar solo los valores no nulos\nplot_sparse_signal(n, h)\n\nEl número de caso seleccionado es: 3\nLongitud de la respuesta impulsional: 26460\nPrimeros 10 valores de h: [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\n\n\n\n\n\n\nLa funcion hcanald devuelve una respuesta impulsional $ h[n] $ que modela un canal digital de dos ecos.\nUn canal digital de dos ecos es un sistema que introduce dos versiones retardadas y atenuadas de la senal original. Estas versiones retardadas y atenuadas se denominan ecos.\nEl modelo matematico de un canal de dos ecos se puede modelar mediante una convolucion entre una senal de entrada $ x[n] $ y la respuesta impulsional del canal $ h[n] $.\n\\[\ny[n] = x[n] * h[n]\n\\]\nDonde $ h[n] $, la respuesta impulsional, tiene la siguiente forma:\n\\[\nh[n] = \\delta[n] + a_1 \\delta[n - d_1] + a_2 \\delta[n - d_2]\n\\]\n\n$ a_1 $: Atenuación del primer eco.\n$ d_1 $: Retardo del primer eco.\n$ a_2 $: Atenuación del segundo eco.\n$ d_2 $: Retardo del segundo eco.\n\nEl primer termino representa la senal original, que pasa sin retraso ni atenuacion.\nEl segundo y tercer termino representan el primer y segundo eco, respectivamente. Con su atenuacion $ a $ y restardo o delay $ d $\nUn canal digital de dos ecos es estable en el sentido BIBO, ya que su respuesta impulsional es finita y absolutamente sumable. Un sistema FIR siempre es estable porque su respuesta impulsional es finita y no incluye retroalimentación (depende solo de los valores actuales y pasados de la entrada).\nEntonces, para modelar un sistema con el comportamiento de la respuesta impulsional dada, se requieren los valores de atenuacion y retardo de cada uno de los ecos.\nEl siguiente script lee el archivo CSV con la respuesta impulsional $ h[n] $, identifica los valores no nulos y obtiene las amplitudes y los retardos de cada uno de los ecos.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\ndef load_hcanal(num_al, base_path=\"data/signals\"):\n    \"\"\"\n    Carga la respuesta impulsional del canal desde un archivo CSV.\n\n    Parámetros:\n        num_al (int): Número de alumno.\n        base_path (str): Directorio base donde están los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n    \"\"\"\n    # Determinar el número de caso (num_al % 5)\n    case_number = num_al % 5\n    print(f\"El número de caso seleccionado es: {case_number}\")\n\n    # Ruta del archivo\n    file_name = f\"case{case_number}_clean.csv\"\n    file_path = os.path.join(base_path, file_name)\n\n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n\n    # Cargar la señal desde el archivo\n    h = np.loadtxt(file_path, delimiter=\",\")\n    n = np.arange(len(h))\n\n    return n, h\n\ndef analyze_impulse_response(n, h):\n    \"\"\"\n    Analiza la respuesta impulsional y obtiene las amplitudes y retardos de los ecos.\n\n    Parámetros:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n\n    Retorna:\n        (a1, d1, a2, d2): Amplitudes y retardos de los dos ecos.\n    \"\"\"\n    # Encontrar los índices donde h[n] es no nulo\n    non_zero_indices = np.nonzero(h)[0]\n    non_zero_values = h[non_zero_indices]\n    \n    # Extraer valores\n    a0 = non_zero_values[0]  # Pico principal (valor unitario)\n    d0 = non_zero_indices[0]  # Pico principal\n    \n    a1 = non_zero_values[1]  # Amplitud del primer eco\n    d1 = non_zero_indices[1]  # Retardo del primer eco\n    \n    a2 = non_zero_values[2]  # Amplitud del segundo eco\n    d2 = non_zero_indices[2]  # Retardo del segundo eco\n    \n    print(\"Valores obtenidos de la respuesta impulsional:\")\n    print(f\"   Amplitud a1: {a1}, Retardo d1: {d1}\")\n    print(f\"   Amplitud a2: {a2}, Retardo d2: {d2}\")\n    \n    return a1, d1, a2, d2, non_zero_indices, non_zero_values\n\ndef plot_nonzero_impulse_response(n, h, a1, d1, a2, d2, indices, values):\n    \"\"\"\n    Grafica la respuesta impulsional mostrando solo los valores no nulos.\n\n    Parámetros:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n        indices (list): Índices de los valores no nulos.\n        values (list): Valores de amplitud no nulos.\n    \"\"\"\n    plt.figure(figsize=(12, 5))\n    \n    # Graficar solo valores no nulos\n    plt.stem(indices, values, linefmt=\"b-\", markerfmt=\"bo\", basefmt=\" \")\n    \n    # Anotar los ecos detectados\n    plt.annotate(f\"Eco 1: a1={a1}, d1={d1}\", (d1, a1), textcoords=\"offset points\", xytext=(0,10), ha='center', color='red')\n    plt.annotate(f\"Eco 2: a2={a2}, d2={d2}\", (d2, a2), textcoords=\"offset points\", xytext=(0,10), ha='center', color='green')\n\n    # Configuración del gráfico\n    plt.title(\"Respuesta Impulsional del Canal (Solo Valores No Nulos)\")\n    plt.xlabel(\"n (instantes)\")\n    plt.ylabel(\"h[n] (amplitud)\")\n    plt.grid()\n    plt.show()\n\n# Parámetros\nnum_al = 14253  # Número de alumno\n\n# 1. Cargar la respuesta impulsional\nn, h = load_hcanal(num_al)\n\n# 2. Analizar la respuesta impulsional para obtener a1, d1, a2, d2\na1, d1, a2, d2, non_zero_indices, non_zero_values = analyze_impulse_response(n, h)\n\n# 3. Graficar solo los valores no nulos\nplot_nonzero_impulse_response(n, h, a1, d1, a2, d2, non_zero_indices, non_zero_values)\n\nEl número de caso seleccionado es: 3\nValores obtenidos de la respuesta impulsional:\n   Amplitud a1: -0.45, Retardo d1: 8820\n   Amplitud a2: 0.2025, Retardo d2: 17640\n\n\n\n\n\n\n\n\n\nUna vez creado el sistema de eco, se toma la senal de audio del archivo audio.wav. Al mismo, se le aplica la funcion implementada para obtener una senal de salida $ y[n] $.\nEl sistema esta dado por el doble eco:\n\n$ a1 = -0.45 $, retardo $ d1 = 8820 $.\n$ a2 = 0.2025 $, retardo $ d2 = 17640 $.\nFinalmente, se grafican la entrada y la salida del sistema.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.io import wavfile\n\n# 1. Función del sistema: Canal de doble eco\ndef double_echo_system(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica un canal de doble eco a la señal de entrada.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n\n    Retorna:\n        y (numpy.ndarray): Señal de salida con el canal de doble eco aplicado.\n    \"\"\"\n    N = len(x)  # Longitud de la señal de entrada\n    y = np.zeros(N + d2)  # Crear salida con espacio suficiente para los retardos\n    \n    # Componente principal (sin retraso)\n    y[:N] += x\n    \n    # Primer eco\n    y[d1:N + d1] += a1 * x\n    \n    # Segundo eco\n    y[d2:N + d2] += a2 * x\n    \n    return y\n\n# 2. Cargar el archivo de audio\ndef load_audio(file_path):\n    \"\"\"\n    Carga una señal de audio y la convierte a mono si es estéreo.\n\n    Parámetros:\n        file_path (str): Ruta del archivo de audio.\n\n    Retorna:\n        fs (int): Frecuencia de muestreo.\n        x (numpy.ndarray): Señal de audio en mono.\n    \"\"\"\n    fs, x = wavfile.read(file_path)  # Cargar archivo de audio\n    \n    # Si la señal es estéreo, convertir a mono\n    if len(x.shape) &gt; 1:\n        print(\"La señal es estéreo. Convirtiendo a mono...\")\n        x = np.mean(x, axis=1)  # Promedio de canales\n    \n    x = x.astype(float)  # Convertir a tipo float\n    return fs, x\n\n# 3. Graficar señales\ndef plot_input_output(x, y, fs):\n    \"\"\"\n    Grafica la señal de entrada y salida.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        y (numpy.ndarray): Señal de salida.\n        fs (int): Frecuencia de muestreo.\n    \"\"\"\n    t_x = np.arange(len(x)) / fs  # Eje temporal de la señal de entrada\n    t_y = np.arange(len(y)) / fs  # Eje temporal de la señal de salida\n\n    plt.figure(figsize=(12, 6))\n\n    # Señal de entrada\n    plt.subplot(2, 1, 1)\n    plt.plot(t_x, x, color='b')\n    plt.title(\"Señal de Entrada x[n]\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Señal de salida\n    plt.subplot(2, 1, 2)\n    plt.plot(t_y, y, color='g')\n    plt.title(\"Señal de Salida y[n] (Canal de Doble Eco Aplicado)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    plt.tight_layout()\n    plt.show()\n\n# -----------------------------------------------\n# Parámetros\naudio_input = \"data/audio.wav\"  # Ruta del archivo de audio\na1, d1 = -0.45, 8820            # Amplitud y retardo del primer eco\na2, d2 = 0.2025, 17640          # Amplitud y retardo del segundo eco\n\n# 1. Cargar la señal de entrada\nfs, x = load_audio(audio_input)\nprint(f\"Frecuencia de muestreo: {fs} Hz\")\nprint(f\"Longitud de la señal de entrada: {len(x)} muestras\")\n\n# 2. Aplicar el sistema de doble eco\ny = double_echo_system(x, a1, d1, a2, d2)\nprint(f\"Longitud de la señal de salida: {len(y)} muestras\")\n\n# 3. Graficar las señales\nplot_input_output(x, y, fs)\n\nLa señal es estéreo. Convirtiendo a mono...\nFrecuencia de muestreo: 48000 Hz\nLongitud de la señal de entrada: 47668 muestras\nLongitud de la señal de salida: 65308 muestras\n\n\n\n\n\n\n\n\n\n\nimport sounddevice as sd\n\ndef play_audio(signal, fs, description):\n    \"\"\"\n    Reproduce una señal de audio.\n\n    Parámetros:\n        signal (numpy.ndarray): Señal de audio.\n        fs (int): Frecuencia de muestreo.\n        description (str): Descripción de la señal para la consola.\n    \"\"\"\n    print(f\"Reproduciendo: {description}...\")\n    sd.play(signal, samplerate=fs)\n    sd.wait()  # Esperar hasta que termine la reproducción\n    print(f\"Reproducción de {description} completada.\\n\")\n\n# 1. Reproducir la señal de entrada\nplay_audio(x, fs, \"Señal de Entrada x[n]\")\n\n# 2. Reproducir la señal de salida\nplay_audio(y, fs, \"Señal de Salida y[n] (Canal de Doble Eco Aplicado)\")\n\nReproduciendo: Señal de Entrada x[n]...\nReproducción de Señal de Entrada x[n] completada.\n\nReproduciendo: Señal de Salida y[n] (Canal de Doble Eco Aplicado)...\nReproducción de Señal de Salida y[n] (Canal de Doble Eco Aplicado) completada.\n\n\n\nSe observa claramente la senal de entrada y la senal de salida con los dos ecos atenuados.\nPara compensar los ecos y que la senal filtrada sea lo mas cercana posible a la senal original, se implementara un filtro FIR que corrija la respuesta impulsional $ h[n] $ del canal de ecos.\nLa idea de implementar un sistema corrector FIR en cascada con el filtro de doble canal, es aproximar la respuesta impulsional total del sistema resultante a una unica delta de Kronecker\nSi la respuesta impulsional total se aproxima a una delta, significa que el sistema (canal + filtro) no introduce distorsion ni retardos en la senal de entrada.\nEl filtro corrige el canal al cancelar los ecos con retardos y atenuaciones opuestos al filtro original.\n\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.io import wavfile\n\n# 1. Función del sistema: Canal de doble eco\ndef double_echo_system(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica un canal de doble eco a la señal de entrada.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n\n    Retorna:\n        y (numpy.ndarray): Señal de salida con el canal de doble eco aplicado.\n    \"\"\"\n    N = len(x)  # Longitud de la señal de entrada\n    y = np.zeros(N + d2)  # Crear salida con espacio suficiente para los retardos\n    \n    # Componente principal (sin retraso)\n    y[:N] += x\n    \n    # Primer eco\n    y[d1:N + d1] += a1 * x\n    \n    # Segundo eco\n    y[d2:N + d2] += a2 * x\n    \n    return y / np.max(np.abs(y))  # Normalizar para evitar desbordamiento\n\n# 2. Corregir la señal con un filtro de 1 rama de retardo\ndef correct_signal_1r(x, a1, d1):\n    \"\"\"\n    Aplica una corrección de 1 rama de retardo a la señal de entrada.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        a1 (float): Amplitud de la primera corrección.\n        d1 (int): Retardo de la primera corrección.\n\n    Retorna:\n        y (numpy.ndarray): Señal corregida.\n    \"\"\"\n    y = x.copy()\n    y[d1:] -= a1 * y[:-d1]  # Corregir el eco\n    return y\n\n# 3. Corregir la señal con un filtro de 2 ramas de retardo\ndef correct_signal_2r(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica una corrección de 2 ramas de retardo a la señal de entrada.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        a1 (float): Amplitud de la primera corrección.\n        d1 (int): Retardo de la primera corrección.\n        a2 (float): Amplitud de la segunda corrección.\n        d2 (int): Retardo de la segunda corrección.\n\n    Retorna:\n        y (numpy.ndarray): Señal corregida.\n    \"\"\"\n    y = x.copy()\n    y[d1:] -= a1 * y[:-d1]  # Corregir primer eco\n    y[d2:] -= a2 * y[:-d2]  # Corregir segundo eco\n    return y\n\n# 4. Cargar el archivo de audio\ndef load_audio(file_path):\n    \"\"\"\n    Carga una señal de audio y la convierte a mono si es estéreo.\n\n    Parámetros:\n        file_path (str): Ruta del archivo de audio.\n\n    Retorna:\n        fs (int): Frecuencia de muestreo.\n        x (numpy.ndarray): Señal de audio en mono.\n    \"\"\"\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n    \n    fs, x = wavfile.read(file_path)  # Cargar archivo de audio\n    \n    # Si la señal es estéreo, convertir a mono\n    if len(x.shape) &gt; 1:\n        print(\"La señal es estéreo. Convirtiendo a mono...\")\n        x = np.mean(x, axis=1)  # Promedio de canales\n    \n    x = x.astype(float)  # Convertir a tipo float\n    return fs, x\n\n# 5. Graficar señales\ndef plot_signals(x, y_echo, y_corr1, y_corr2, fs):\n    \"\"\"\n    Grafica las señales de entrada, con ecos y las corregidas.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        y_echo (numpy.ndarray): Señal con ecos.\n        y_corr1 (numpy.ndarray): Señal corregida (1 rama de retardo).\n        y_corr2 (numpy.ndarray): Señal corregida (2 ramas de retardo).\n        fs (int): Frecuencia de muestreo.\n    \"\"\"\n    t_x = np.arange(len(x)) / fs  # Eje temporal de la señal de entrada\n    t_y = np.arange(len(y_echo)) / fs  # Eje temporal de las señales de salida\n\n    plt.figure(figsize=(12, 12))\n\n    # Señal de entrada original\n    plt.subplot(4, 1, 1)\n    plt.plot(t_x, x, color='b')\n    plt.title(\"Señal Original x[n]\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Señal con ecos\n    plt.subplot(4, 1, 2)\n    plt.plot(t_y, y_echo, color='g')\n    plt.title(\"Señal con Ecos y[n] (Canal de Doble Eco)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Señal corregida con 1 rama de retardo\n    plt.subplot(4, 1, 3)\n    plt.plot(t_y, y_corr1, color='r')\n    plt.title(\"Señal Corregida (Filtro con 1 Rama de Retardo)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Señal corregida con 2 ramas de retardo\n    plt.subplot(4, 1, 4)\n    plt.plot(t_y, y_corr2, color='m')\n    plt.title(\"Señal Corregida (Filtro con 2 Ramas de Retardo)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    plt.tight_layout()\n    plt.show()\n\n# -----------------------------------------------\n# Parámetros\naudio_input = \"data/audio.wav\"  # Ruta del archivo de audio\na1, d1 = -0.45, 8820            # Amplitud y retardo del primer eco\na2, d2 = 0.2025, 17640          # Amplitud y retardo del segundo eco\n\n# 1. Cargar la señal de entrada\nfs, x = load_audio(audio_input)\nprint(f\"Frecuencia de muestreo: {fs} Hz\")\nprint(f\"Longitud de la señal de entrada: {len(x)} muestras\")\n\n# 2. Aplicar el sistema de doble eco\ny_echo = double_echo_system(x, a1, d1, a2, d2)\n\n# 3. Corregir la señal\ny_corr1 = correct_signal_1r(y_echo, a1, d1)\ny_corr2 = correct_signal_2r(y_echo, a1, d1, a2, d2)\n\n# 4. Graficar todas las señales\nplot_signals(x, y_echo, y_corr1, y_corr2, fs)\n\nLa señal es estéreo. Convirtiendo a mono...\nFrecuencia de muestreo: 48000 Hz\nLongitud de la señal de entrada: 47668 muestras",
    "crumbs": [
      "Ejercicio 2",
      "`hcanald.py`"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Práctica con Utilitario - IPS 2024",
    "section": "",
    "text": "Autor: Gian Franco Lasala - 01425/3\nEn esta página encontrarás una breve explicación sobre Quarto y Binder, además de los enlaces a los ejercicios resueltos."
  },
  {
    "objectID": "index.html#qué-es-quarto",
    "href": "index.html#qué-es-quarto",
    "title": "Práctica con Utilitario - IPS 2024",
    "section": "1 ¿Qué es Quarto?",
    "text": "1 ¿Qué es Quarto?\nQuarto es una herramienta de código abierto que permite crear documentos, sitios web, libros y presentaciones interactivas a partir de archivos Markdown (.qmd) y Jupyter Notebooks (.ipynb).\nQuarto se utiliza para generar contenido dinámico y reproducible, especialmente útil en ciencia de datos y enseñanza."
  },
  {
    "objectID": "index.html#qué-es-binder",
    "href": "index.html#qué-es-binder",
    "title": "Práctica con Utilitario - IPS 2024",
    "section": "2 ¿Qué es Binder?",
    "text": "2 ¿Qué es Binder?\nBinder es un servicio gratuito que permite ejecutar notebooks interactivos directamente en la nube. Simplemente, seleccionas un repositorio de GitHub que contenga tus archivos y Binder proporciona un entorno ejecutable en tiempo real.\nBinder es ideal para compartir proyectos interactivos sin necesidad de configuraciones locales."
  },
  {
    "objectID": "index.html#ejecuta-los-ejercicios-con-binder",
    "href": "index.html#ejecuta-los-ejercicios-con-binder",
    "title": "Práctica con Utilitario - IPS 2024",
    "section": "3 Ejecuta los Ejercicios con Binder 🚀",
    "text": "3 Ejecuta los Ejercicios con Binder 🚀\nHaz clic en el siguiente botón para abrir este proyecto en Binder y ejecutarlo en un entorno interactivo:\n\n\n\nLaunch Binder"
  },
  {
    "objectID": "index.html#ejercicios-resueltos",
    "href": "index.html#ejercicios-resueltos",
    "title": "Práctica con Utilitario - IPS 2024",
    "section": "4 Ejercicios Resueltos",
    "text": "4 Ejercicios Resueltos\nA continuación, encontrarás los enlaces a los ejercicios resueltos:\n\n4.1 Ejercicio 1\n\nSeñal de Entrada\nRespuesta Impulsional del Sistema\nAnálisis Numérico del Sistema\nSalida del Sistema\n\n\n\n4.2 Ejercicio 2\n\nRespuesta Impulsional del Canal"
  },
  {
    "objectID": "index.html#accede-a-la-versión-estática",
    "href": "index.html#accede-a-la-versión-estática",
    "title": "Práctica con Utilitario - IPS 2024",
    "section": "5 Accede a la Versión Estática",
    "text": "5 Accede a la Versión Estática\nSi prefieres acceder al sitio web estático, puedes visitar el siguiente enlace:\nVersión Estática"
  },
  {
    "objectID": "index.html#repositorio-del-proyecto",
    "href": "index.html#repositorio-del-proyecto",
    "title": "Práctica con Utilitario - IPS 2024",
    "section": "6 Repositorio del Proyecto",
    "text": "6 Repositorio del Proyecto\nEl código fuente de este proyecto está disponible en el siguiente repositorio de GitHub:\nRepositorio GitHub"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html",
    "href": "notebooks/ejercicio1/03_h_systems_num.html",
    "title": "Sistemas: resolucion numerica",
    "section": "",
    "text": "Para implementar los sistemas discretos, calcular la respuesta impulsional y aplicar la Transformada de Fourier en Tiempo Discreto (TFTD), se utilizan las siguientes librerías y funciones de Python:\n\nNumPy es fundamental para realizar cálculos numéricos en Python.\n\nMatplotlib se utiliza para graficar los resultados obtenidos. Permite visualizar tanto señales en el dominio del tiempo como en el dominio de la frecuencia.\nnp.zeros(N): Crea un arreglo de ceros con $ N $ elementos.\n\nnp.arange(start, stop): Crea una secuencia de números entre start y stop.\n\nnp.convolve(x, h, mode): Realiza la convolución entre dos señales.\n\nnp.fft.fft(h): Calcula la Transformada de Fourier de la señal $ h $.\n\nnp.fft.fftfreq(N, d): Devuelve las frecuencias correspondientes a la FFT.\nplt.stem(x, y): Grafica una señal discreta.\n\nplt.plot(x, y): Grafica una señal continua o en el dominio de la frecuencia.\n\nplt.title(), plt.xlabel(), plt.ylabel(): Añaden títulos y etiquetas a los gráficos.\n\nplt.grid(): Activa la cuadrícula en el gráfico.\n\nSe utilizan funciones personalizadas para implementar cada uno de los sistemas en forma de convolución. Cada sistema será una función que recibirá una señal de entrada $ x[n] $ y devolverá la señal de salida $ y[n] $.\nMétodo:\n- La respuesta de cada sistema se obtiene utilizando la convolución entre la entrada $ x[n] $ y la respuesta impulsional $ h[n] $.\n- Se aplicará la TFTD (mediante np.fft.fft) a la respuesta impulsional para verificar que coincide con la respuesta en frecuencia analítica.",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html#librerias",
    "href": "notebooks/ejercicio1/03_h_systems_num.html#librerias",
    "title": "Sistemas: resolucion numerica",
    "section": "",
    "text": "Para implementar los sistemas discretos, calcular la respuesta impulsional y aplicar la Transformada de Fourier en Tiempo Discreto (TFTD), se utilizan las siguientes librerías y funciones de Python:\n\nNumPy es fundamental para realizar cálculos numéricos en Python.\n\nMatplotlib se utiliza para graficar los resultados obtenidos. Permite visualizar tanto señales en el dominio del tiempo como en el dominio de la frecuencia.\nnp.zeros(N): Crea un arreglo de ceros con $ N $ elementos.\n\nnp.arange(start, stop): Crea una secuencia de números entre start y stop.\n\nnp.convolve(x, h, mode): Realiza la convolución entre dos señales.\n\nnp.fft.fft(h): Calcula la Transformada de Fourier de la señal $ h $.\n\nnp.fft.fftfreq(N, d): Devuelve las frecuencias correspondientes a la FFT.\nplt.stem(x, y): Grafica una señal discreta.\n\nplt.plot(x, y): Grafica una señal continua o en el dominio de la frecuencia.\n\nplt.title(), plt.xlabel(), plt.ylabel(): Añaden títulos y etiquetas a los gráficos.\n\nplt.grid(): Activa la cuadrícula en el gráfico.\n\nSe utilizan funciones personalizadas para implementar cada uno de los sistemas en forma de convolución. Cada sistema será una función que recibirá una señal de entrada $ x[n] $ y devolverá la señal de salida $ y[n] $.\nMétodo:\n- La respuesta de cada sistema se obtiene utilizando la convolución entre la entrada $ x[n] $ y la respuesta impulsional $ h[n] $.\n- Se aplicará la TFTD (mediante np.fft.fft) a la respuesta impulsional para verificar que coincide con la respuesta en frecuencia analítica.",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html#sistema-1",
    "href": "notebooks/ejercicio1/03_h_systems_num.html#sistema-1",
    "title": "Sistemas: resolucion numerica",
    "section": "Sistema 1",
    "text": "Sistema 1\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función que implementa el Sistema 1\ndef sistema1(x):\n    \"\"\"\n    Implementa el sistema 1: y[n] = 0.5*x[n] + 0.5*x[n-1]\n    Entrada: x -&gt; Señal de entrada\n    Salida: y -&gt; Señal de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.5 * x[n]  # Primer término\n        if n &gt; 0:\n            y[n] += 0.5 * x[n-1]  # Segundo término (desplazado)\n    return y\n\n# Generar la señal de entrada: impulso unitario δ[n]\nN = 20  # Duración de la señal\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema1(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos para mayor resolución\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre -π y π\nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en ω = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 1\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia ∠H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html#sistema-2",
    "href": "notebooks/ejercicio1/03_h_systems_num.html#sistema-2",
    "title": "Sistemas: resolucion numerica",
    "section": "Sistema 2",
    "text": "Sistema 2\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función que implementa el Sistema 2\ndef sistema2(x):\n    \"\"\"\n    Implementa el sistema 2: y[n] = 0.5*x[n] - 0.5*x[n-1]\n    Entrada: x -&gt; Señal de entrada\n    Salida: y -&gt; Señal de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.5 * x[n]  # Primer término\n        if n &gt; 0:\n            y[n] -= 0.5 * x[n-1]  # Segundo término (desplazado y restado)\n    return y\n\n# Generar la señal de entrada: impulso unitario δ[n]\nN = 20  # Duración de la señal\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema2(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre -π y π\nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en ω = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 2\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia ∠H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html#sistema-3",
    "href": "notebooks/ejercicio1/03_h_systems_num.html#sistema-3",
    "title": "Sistemas: resolucion numerica",
    "section": "Sistema 3",
    "text": "Sistema 3\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función que implementa el Sistema 3\ndef sistema3(x):\n    \"\"\"\n    Implementa el sistema 3: y[n] = 0.25*x[n] + 0.25*x[n-1] + 0.5*y[n-1]\n    Entrada: x -&gt; Señal de entrada\n    Salida: y -&gt; Señal de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.25 * x[n]  # Primer término\n        if n &gt; 0:\n            y[n] += 0.25 * x[n-1]  # Segundo término (desplazado)\n            y[n] += 0.5 * y[n-1]   # Término recursivo\n    return y\n\n# Generar la señal de entrada: impulso unitario δ[n]\nN = 20  # Duración de la señal\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema3(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre -π y π\nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en ω = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 3\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia ∠H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función que implementa el Sistema 4\ndef sistema4(x):\n    \"\"\"\n    Implementa el sistema 4: y[n] = 0.25*x[n] - 0.25*x[n-1] - 0.5*y[n-1]\n    Entrada: x -&gt; Señal de entrada\n    Salida: y -&gt; Señal de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.25 * x[n]  # Primer término\n        if n &gt; 0:\n            y[n] -= 0.25 * x[n-1]  # Segundo término (desplazado y restado)\n            y[n] -= 0.5 * y[n-1]   # Término recursivo (negativo)\n    return y\n\n# Generar la señal de entrada: impulso unitario δ[n]\nN = 20  # Duración de la señal\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema4(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre -π y π\nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en ω = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 4\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia ∠H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/01_x_input.html",
    "href": "notebooks/ejercicio1/01_x_input.html",
    "title": "1.1 Señal Discreta",
    "section": "",
    "text": "En esta sección, se genera la señal discreta $ x[n] $, se grafica y analiza sus componentes de frecuencia mediante la Transformada de Fourier Discreta (TFTD).",
    "crumbs": [
      "Ejercicio 1",
      "**1.1 Señal Discreta**"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/01_x_input.html#sistemas-discretos",
    "href": "notebooks/ejercicio1/01_x_input.html#sistemas-discretos",
    "title": "1.1 Señal Discreta",
    "section": "Sistemas Discretos",
    "text": "Sistemas Discretos\nSe dan sistemas están definidos por las siguientes ecuaciones en diferencias:\n\nSistema 1:\n\\[\ny[n] = \\frac{1}{2}x[n] + \\frac{1}{2}x[n-1]\n\\]\nSistema 2:\n$$ y[n] = x[n] - x[n-1]\n$$\nSistema 3:\n\\[\ny[n] = \\frac{1}{4}x[n] + \\frac{1}{4}x[n-1] + \\frac{1}{2}y[n-1]\n\\]\nSistema 4:\n\\[\ny[n] = \\frac{1}{4}x[n] - \\frac{1}{4}x[n-1] - \\frac{1}{2}y[n-1]\n\\]",
    "crumbs": [
      "Ejercicio 1",
      "**1.1 Señal Discreta**"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html",
    "href": "notebooks/librerias/librerias.html",
    "title": "Librerias",
    "section": "",
    "text": "Propósito: Manipulación eficiente de matrices y operaciones matemáticas fundamentales.\nFunciones clave:\n- np.arange()\n- Genera arreglos de valores equiespaciados.\n- Ejemplo: Generar instantes de tiempo para señales: n = np.arange(0, N)\n- np.zeros()\n- Crea arreglos inicializados con ceros.\n- Ejemplo: y = np.zeros(N) para inicializar una señal.\n- np.fft.fft()\n- Calcula la Transformada de Fourier Discreta (TFTD) de una señal.\n- Ejemplo: fft_x = np.fft.fft(x)\n- np.fft.fftfreq()\n- Calcula las frecuencias correspondientes a la FFT.\n- Ejemplo: frequencies = np.fft.fftfreq(N, d=1/fs)\n- np.fft.fftshift()\n- Desplaza las frecuencias centrando en ( = 0 ).\n- Ejemplo: fft_shifted = np.fft.fftshift(fft_x)\n- np.convolve()\n- Realiza la convolución entre dos señales.\n- Ejemplo: y = np.convolve(x, h, mode='full')\n\n\n\n\nPropósito: Visualización de señales en el dominio del tiempo y frecuencia.\nFunciones clave:\n- plt.plot()\n- Grafica una señal continua.\n- Ejemplo: plt.plot(t, x)\n- plt.stem()\n- Grafica señales discretas (en puntos).\n- Ejemplo: plt.stem(n, x)\n- plt.title(), plt.xlabel(), plt.ylabel()\n- Personalizan títulos y etiquetas de gráficos.\n- Ejemplo: plt.title(\"Señal x[n]\")\n- plt.grid()\n- Activa una cuadrícula en el gráfico.\n- Ejemplo: plt.grid(True)\n- plt.tight_layout()\n- Ajusta automáticamente la distribución de los subgráficos.\n- plt.show()\n- Muestra los gráficos.\n\n\n\n\nPropósito: Procesamiento avanzado de señales, análisis de sistemas LTI.\nSubmódulo clave: scipy.signal\nFunciones clave:\n- signal.dlti()\n- Representa sistemas LTI (Lineales e Invariantes en el Tiempo) en tiempo discreto.\n- Ejemplo: system = signal.dlti(b, a)\n- signal.dimpulse()\n- Calcula la respuesta impulsional de un sistema LTI discreto.\n- Ejemplo: t, h = signal.dimpulse(system, n=20)\n- signal.lfilter()\n- Aplica un filtro FIR o IIR a una señal.\n- Ejemplo: y = signal.lfilter(b, a, x)\n- signal.firwin()\n- Diseña filtros FIR con características específicas.\n- Ejemplo: Crear un filtro pasa bajos: b = signal.firwin(N, cutoff)\n- signal.freqz()\n- Calcula y grafica la respuesta en frecuencia de un sistema.\n- Ejemplo: w, h = signal.freqz(b, a, worN=512)\n\n\n\n\nPropósito: Lectura y escritura de archivos de audio.\nFunciones clave:\n- sf.read()\n- Carga archivos de audio (wav, flac, etc.).\n- Ejemplo: fs, x = sf.read('audio.wav')\n- sf.write()\n- Guarda una señal en un archivo de audio.\n- Ejemplo: sf.write('output.wav', y, fs)\n\n\n\n\nPropósito: Entorno interactivo para la ejecución de código y visualización.\nHerramientas clave:\n- IPython.display.Audio()\n- Reproduce una señal de audio en una celda de Jupyter.\n- Ejemplo: Audio(y, rate=fs)\n- Markdown y LaTeX:\n- Documentación de reportes, uso de fórmulas matemáticas.\n- Ejemplo: $$ y[n] = x[n] * h[n] $$\n\n\n\n\nPropósito: Ejecutar scripts de Octave/MATLAB desde Python.\nFunciones clave:\n- Oct2Py()\n- Inicializa una sesión de Octave.\n- Ejemplo: oc = Oct2Py()\n- oc.run()\n- Ejecuta scripts de Octave.\n- Ejemplo: oc.run('hcanald.m')\n- oc.addpath()\n- Agrega rutas a carpetas que contienen archivos Octave/MATLAB.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html#librerías-utilizadas",
    "href": "notebooks/librerias/librerias.html#librerías-utilizadas",
    "title": "Librerias",
    "section": "",
    "text": "Propósito: Manipulación eficiente de matrices y operaciones matemáticas fundamentales.\nFunciones clave:\n- np.arange()\n- Genera arreglos de valores equiespaciados.\n- Ejemplo: Generar instantes de tiempo para señales: n = np.arange(0, N)\n- np.zeros()\n- Crea arreglos inicializados con ceros.\n- Ejemplo: y = np.zeros(N) para inicializar una señal.\n- np.fft.fft()\n- Calcula la Transformada de Fourier Discreta (TFTD) de una señal.\n- Ejemplo: fft_x = np.fft.fft(x)\n- np.fft.fftfreq()\n- Calcula las frecuencias correspondientes a la FFT.\n- Ejemplo: frequencies = np.fft.fftfreq(N, d=1/fs)\n- np.fft.fftshift()\n- Desplaza las frecuencias centrando en ( = 0 ).\n- Ejemplo: fft_shifted = np.fft.fftshift(fft_x)\n- np.convolve()\n- Realiza la convolución entre dos señales.\n- Ejemplo: y = np.convolve(x, h, mode='full')\n\n\n\n\nPropósito: Visualización de señales en el dominio del tiempo y frecuencia.\nFunciones clave:\n- plt.plot()\n- Grafica una señal continua.\n- Ejemplo: plt.plot(t, x)\n- plt.stem()\n- Grafica señales discretas (en puntos).\n- Ejemplo: plt.stem(n, x)\n- plt.title(), plt.xlabel(), plt.ylabel()\n- Personalizan títulos y etiquetas de gráficos.\n- Ejemplo: plt.title(\"Señal x[n]\")\n- plt.grid()\n- Activa una cuadrícula en el gráfico.\n- Ejemplo: plt.grid(True)\n- plt.tight_layout()\n- Ajusta automáticamente la distribución de los subgráficos.\n- plt.show()\n- Muestra los gráficos.\n\n\n\n\nPropósito: Procesamiento avanzado de señales, análisis de sistemas LTI.\nSubmódulo clave: scipy.signal\nFunciones clave:\n- signal.dlti()\n- Representa sistemas LTI (Lineales e Invariantes en el Tiempo) en tiempo discreto.\n- Ejemplo: system = signal.dlti(b, a)\n- signal.dimpulse()\n- Calcula la respuesta impulsional de un sistema LTI discreto.\n- Ejemplo: t, h = signal.dimpulse(system, n=20)\n- signal.lfilter()\n- Aplica un filtro FIR o IIR a una señal.\n- Ejemplo: y = signal.lfilter(b, a, x)\n- signal.firwin()\n- Diseña filtros FIR con características específicas.\n- Ejemplo: Crear un filtro pasa bajos: b = signal.firwin(N, cutoff)\n- signal.freqz()\n- Calcula y grafica la respuesta en frecuencia de un sistema.\n- Ejemplo: w, h = signal.freqz(b, a, worN=512)\n\n\n\n\nPropósito: Lectura y escritura de archivos de audio.\nFunciones clave:\n- sf.read()\n- Carga archivos de audio (wav, flac, etc.).\n- Ejemplo: fs, x = sf.read('audio.wav')\n- sf.write()\n- Guarda una señal en un archivo de audio.\n- Ejemplo: sf.write('output.wav', y, fs)\n\n\n\n\nPropósito: Entorno interactivo para la ejecución de código y visualización.\nHerramientas clave:\n- IPython.display.Audio()\n- Reproduce una señal de audio en una celda de Jupyter.\n- Ejemplo: Audio(y, rate=fs)\n- Markdown y LaTeX:\n- Documentación de reportes, uso de fórmulas matemáticas.\n- Ejemplo: $$ y[n] = x[n] * h[n] $$\n\n\n\n\nPropósito: Ejecutar scripts de Octave/MATLAB desde Python.\nFunciones clave:\n- Oct2Py()\n- Inicializa una sesión de Octave.\n- Ejemplo: oc = Oct2Py()\n- oc.run()\n- Ejecuta scripts de Octave.\n- Ejemplo: oc.run('hcanald.m')\n- oc.addpath()\n- Agrega rutas a carpetas que contienen archivos Octave/MATLAB.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html#procesamiento-de-señales-utilizado",
    "href": "notebooks/librerias/librerias.html#procesamiento-de-señales-utilizado",
    "title": "Librerias",
    "section": "Procesamiento de Señales Utilizado",
    "text": "Procesamiento de Señales Utilizado\n\n1. Respuesta Impulsional ( h[n] )\nLa respuesta impulsional de un sistema fue calculada usando: - Análisis manual de las ecuaciones en diferencias.\n- Implementación con scipy.signal.dimpulse.\n- Graficada usando matplotlib.stem().\n\n\n2. Transformada de Fourier en Tiempo Discreto (TFTD)\n\nCalculada usando np.fft.fft.\n\nFrecuencias generadas con np.fft.fftfreq y desplazadas con np.fft.fftshift.\n\nMagnitud y fase de la señal graficadas para análisis.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html#filtros-implementados",
    "href": "notebooks/librerias/librerias.html#filtros-implementados",
    "title": "Librerias",
    "section": "Filtros Implementados",
    "text": "Filtros Implementados\n\n1. Sistemas LTI FIR\nFiltros implementados en base a las ecuaciones en diferencias dadas.\n- Usamos convolución (np.convolve) para aplicar la respuesta impulsional.\n- Ejemplo: Canal con doble eco.\n\n\n2. Filtros Correctores\n\nFiltro FIR de 1 rama de retardo: Atenuación de un solo eco.\n\nFiltro FIR de 2 ramas de retardo: Corrección de dos ecos simultáneamente.\n\nAmbos implementados utilizando np.convolve() y analizados en el tiempo y frecuencia.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html#procesamiento-de-audio",
    "href": "notebooks/librerias/librerias.html#procesamiento-de-audio",
    "title": "Librerias",
    "section": "Procesamiento de Audio",
    "text": "Procesamiento de Audio\n\nCargado y guardado con soundfile.\n\nVisualización en tiempo usando matplotlib.\n\nAnálisis en frecuencia usando la TFTD.\n\nReproducción de audio en Jupyter con IPython.display.Audio.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  }
]