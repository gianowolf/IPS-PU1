[
  {
    "objectID": "notebooks/ejercicio1/02_h_system.html",
    "href": "notebooks/ejercicio1/02_h_system.html",
    "title": "Sistemas",
    "section": "",
    "text": "Dados los sistemas $ S1, S2, S3, S4 $ se procede a encontrar de forma analitica su respuesta impulsional y su respuesta en frecuencia.",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/02_h_system.html#sistema-s1",
    "href": "notebooks/ejercicio1/02_h_system.html#sistema-s1",
    "title": "Sistemas",
    "section": "Sistema S1",
    "text": "Sistema S1\nLa ecuaci칩n en diferencias del sistema 1 es:\n\\[\ny[n] = \\frac{1}{2}x[n] + \\frac{1}{2}x[n-1].\n\\]\nLa respuesta impulsional se obtiene aplicando un impulso unitario $ x[n] = $ como entrada. Por definici칩n:\n\\[\n\\delta[n] =\n\\begin{cases}\n1 & \\text{si } n = 0, \\\\\n0 & \\text{si } n \\neq 0.\n\\end{cases}\n\\]\nSustituyendo $ x[n] = $ en la ecuaci칩n:\n\\[\nh[n] = \\frac{1}{2}\\delta[n] + \\frac{1}{2}\\delta[n-1].\n\\]\nEsto implica que $ h[n] $ es la suma de dos impulsos desplazados:\n- Un impulso en $ n = 0 $ con coeficiente $ $.\n- Un impulso en $ n = 1 $ con coeficiente $ $.\nPor lo tanto, la respuesta impulsional $ h[n] $ es:\n\\[\nh[n] =\n\\begin{cases}\n\\frac{1}{2} & \\text{si } n = 0, \\\\\n\\frac{1}{2} & \\text{si } n = 1, \\\\\n0 & \\text{en otro caso}.\n\\end{cases}\n\\]\nLa respuesta en frecuencia se obtiene aplicando la Transformada de Fourier en Tiempo Discreto (TFTD) a $ h[n] $. La definici칩n de la TFTD es:\n\\[\nH(e^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} h[n] e^{-j\\omega n}.\n\\]\nDado que $ h[n] $ tiene valores distintos de cero solo en $ n = 0 $ y $ n = 1 $, sustituimos estos valores en la definici칩n:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2}e^{-j\\omega \\cdot 0} + \\frac{1}{2}e^{-j\\omega \\cdot 1}.\n\\]\nSimplificamos los t칠rminos exponenciales:\n- $ e^{-j} = 1 $.\n- $ e^{-j} = e^{-j} $.\nPor lo tanto:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2} \\left( 1 + e^{-j\\omega} \\right).\n\\]\nel modulo de $ H(e^{j}) $ se calcula como:\n\\[\n|H(e^{j\\omega})| = \\sqrt{\\text{Re}(H)^2 + \\text{Im}(H)^2}.\n\\]\nSustituyendo $ H(e^{j}) $:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2} \\left( 1 + e^{-j\\omega} \\right).\n\\]\nSabemos que $ e^{-j} $ se puede descomponer como $ () - j() $. Por lo tanto:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2} \\left( 1 + \\cos(\\omega) - j\\sin(\\omega) \\right).\n\\]\nLa parte real y la parte imaginaria son:\n- Parte real: $ (H) = (1 + ()) $.\n- Parte imaginaria: $ (H) = -() $.\nLa magnitud es entonces:\n\\[\n|H(e^{j\\omega})| = \\frac{1}{2} \\sqrt{(1 + \\cos(\\omega))^2 + \\sin^2(\\omega)}.\n\\]\nSimplificamos utilizando la identidad trigonom칠trica $ ^2() + ^2() = 1 $:\n\\[\n|H(e^{j\\omega})| = \\frac{1}{2} \\sqrt{1 + 2\\cos(\\omega) + 1}.\n\\]\nSimplificando a칰n m치s:\n\\[\n|H(e^{j\\omega})| = \\sqrt{\\frac{1 + \\cos(\\omega)}{2}}.\n\\]\nLa fase de $ H(e^{j}) $ se calcula como:\n\\[\n\\angle H(e^{j\\omega}) = \\arctan\\left( \\frac{\\text{Im}(H)}{\\text{Re}(H)} \\right).\n\\]\nSustituyendo los valores de la parte real e imaginaria:\n\\[\n\\angle H(e^{j\\omega}) = \\arctan\\left( \\frac{-\\sin(\\omega)}{1 + \\cos(\\omega)} \\right).\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Respuesta impulsional h[n] - Sistema 1\nn = np.arange(0, 10)  # Instantes de tiempo\nh = np.zeros_like(n, dtype=float)\nh[0] = 0.5  # Valor en n = 0\nh[1] = 0.5  # Valor en n = 1\n\n# Respuesta en frecuencia H(e^jw)\nomega = np.linspace(-np.pi, np.pi, 1000)  # Frecuencias normalizadas\nH = 0.5 * (1 + np.exp(-1j * omega))  # Respuesta en frecuencia\n\n# Calcular magnitud y fase\nmagnitude = np.abs(H)\nphase = np.angle(H)\n\n# Graficar la respuesta impulsional\nplt.figure(figsize=(12, 8))\n\nplt.subplot(3, 1, 1)\nplt.stem(n, h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 1\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Graficar la magnitud de la respuesta en frecuencia\nplt.subplot(3, 1, 2)\nplt.plot(omega, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Graficar la fase de la respuesta en frecuencia\nplt.subplot(3, 1, 3)\nplt.plot(omega, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/02_h_system.html#sistema-2",
    "href": "notebooks/ejercicio1/02_h_system.html#sistema-2",
    "title": "Sistemas",
    "section": "Sistema 2",
    "text": "Sistema 2\nLa ecuaci칩n de diferencias del Sistema 2 es:\n\\[\ny[n] = \\frac{1}{2}x[n] - \\frac{1}{2}x[n-1].\n\\]\nLa salida del sistema cuando la entrada es $ x[n] = $:\n\\[\nh[n] = \\frac{1}{2}\\delta[n] - \\frac{1}{2}\\delta[n-1].\n\\]\nLa Transformada de Fourier de $ h[n] $ es:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2}(1 - e^{-j\\omega}).\n\\]\nSustituyendo $ e^{-j} = () - j() $, obtenemos:\n\\[\nH(e^{j\\omega}) = \\frac{1}{2} \\left( 1 - \\cos(\\omega) + j\\sin(\\omega) \\right).\n\\]\nModulo:\n\\[\n|H(e^{j\\omega})| = \\sqrt{\\frac{1 - \\cos(\\omega)}{2}}.\n\\]\nFase:\n\\[\n\\angle H(e^{j\\omega}) = \\arctan\\left( \\frac{\\sin(\\omega)}{1 - \\cos(\\omega)} \\right).\n\\]\n\n# Respuesta impulsional h[n] - Sistema 2\nn = np.arange(0, 10)  # Instantes de tiempo\nh = np.zeros_like(n, dtype=float)\nh[0] = 0.5  # Valor en n = 0\nh[1] = -0.5 # Valor en n = 1\n\n# Respuesta en frecuencia H(e^jw)\nomega = np.linspace(-np.pi, np.pi, 1000)  # Frecuencias normalizadas\nH = 0.5 * (1 - np.exp(-1j * omega))  # Respuesta en frecuencia\n\n# Calcular magnitud y fase\nmagnitude = np.abs(H)\nphase = np.angle(H)\n\n# Graficar la respuesta impulsional\nplt.figure(figsize=(12, 8))\n\nplt.subplot(3, 1, 1)\nplt.stem(n, h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 2\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Graficar la magnitud de la respuesta en frecuencia\nplt.subplot(3, 1, 2)\nplt.plot(omega, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Graficar la fase de la respuesta en frecuencia\nplt.subplot(3, 1, 3)\nplt.plot(omega, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nResoluci칩n Anal칤tica del Sistema 3\nLa ecuaci칩n de diferencias del Sistema 3 es:\n\\[\ny[n] = \\frac{1}{4}x[n] + \\frac{1}{4}x[n-1] + \\frac{1}{2}y[n-1].\n\\]\nLa salida del sistema $ y[n] $ cuando la entrada es $ x[n] = $ se obtiene resolviendo la ecuaci칩n en diferencias de manera recursiva.\nInicialmente, suponemos que $ y[n] = h[n] $ y que:\n- $ x[n] = $: el impulso unitario.\n- $ y[n] = 0 $ para $ n &lt; 0 $ (condici칩n inicial).\nSustituyendo $ x[n] = $ en la ecuaci칩n:\nPara $ n = 0 \\(:\\)$ h[0] = + + h[-1]. \\[  \nDado que $ \\delta[0] = 1 $, $ \\delta[-1] = 0 $, y $ h[-1] = 0 $:  \n\\] h[0] = . $$\nPara $ n = 1 \\(:\\)$ h[1] = + + h[0]. \\[  \nSustituyendo $ \\delta[1] = 0 $, $ \\delta[0] = 1 $, y $ h[0] = \\frac{1}{4} $:  \n\\] h[1] = + = + = . $$\nPara $ n = 2 \\(:\\)$ h[2] = + + h[1]. \\[  \nSustituyendo $ \\delta[2] = 0 $, $ \\delta[1] = 0 $, y $ h[1] = \\frac{3}{8} $:  \n\\] h[2] = = . $$\nDe manera general, la respuesta impulsional $ h[n] $ es una secuencia exponencial decreciente, debido al t칠rmino recursivo $ y[n-1] $.\nLa respuesta en frecuencia\n\\[\nH(e^{j\\omega}) = \\frac{B(e^{j\\omega})}{A(e^{j\\omega})},\n\\]\ndonde:\n- $ B(e^{j}) $ es el polinomio del numerador correspondiente a $ x[n] $.\n- $ A(e^{j}) $ es el polinomio del denominador correspondiente a $ y[n] $.\nLos coeficientes son:\n- Numerador: $ B(z) = + z^{-1} $.\n- Denominador: $ A(z) = 1 - z^{-1} $.\nPor lo tanto:\n\\[\nH(e^{j\\omega}) = \\frac{\\frac{1}{4} + \\frac{1}{4}e^{-j\\omega}}{1 - \\frac{1}{2}e^{-j\\omega}}.\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Respuesta impulsional h[n] - Sistema 3 (exponencial decreciente)\nn = np.arange(0, 10)  # Instantes de tiempo\nh = (1 / 4) * (1 / 2) ** n  # Respuesta impulsional anal칤tica\n\n# Respuesta en frecuencia H(e^jw)\nomega = np.linspace(-np.pi, np.pi, 1000)  # Frecuencias normalizadas\nnumerator = 0.25 + 0.25 * np.exp(-1j * omega)  # Numerador\ndenominator = 1 - 0.5 * np.exp(-1j * omega)  # Denominador\nH = numerator / denominator  # Respuesta en frecuencia\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H)  # Magnitud de H(e^jw)\nphase = np.angle(H)    # Fase de H(e^jw)\n\n# Graficar la respuesta impulsional\nplt.figure(figsize=(12, 8))\n\nplt.subplot(3, 1, 1)\nplt.stem(n, h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 3\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Graficar la magnitud de la respuesta en frecuencia\nplt.subplot(3, 1, 2)\nplt.plot(omega, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Graficar la fase de la respuesta en frecuencia\nplt.subplot(3, 1, 3)\nplt.plot(omega, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nSistema 4\nLa ecuaci칩n en diferencias del Sistema 4 es:\n\\[\ny[n] = \\frac{1}{4}x[n] - \\frac{1}{4}x[n-1] - \\frac{1}{2}y[n-1].\n\\]\nPara obtener la respuesta impulsional $ h[n] $, aplicamos como entrada el impulso unitario $ x[n] = $. La ecuaci칩n en diferencias se resuelve de forma recursiva:\nCondiciones iniciales: - $ x[n] = $ para $ n = 0 $.\n- $ h[n] = 0 $ para $ n &lt; 0 $.\n\nPara $ n = 0 $:\n\n\\[\nh[0] = \\frac{1}{4}\\delta[0] - \\frac{1}{4}\\delta[-1] - \\frac{1}{2}h[-1].\n\\]\nSustituyendo $ = 1 $, $ = 0 $, y $ h[-1] = 0 $:\n\\[\nh[0] = \\frac{1}{4}.\n\\]\n\nPara $ n = 1 $:\n\n\\[\nh[1] = \\frac{1}{4}\\delta[1] - \\frac{1}{4}\\delta[0] - \\frac{1}{2}h[0].\n\\]\nSustituyendo $ = 0 $, $ = 1 $, y $ h[0] = $:\n\\[\nh[1] = -\\frac{1}{4} - \\frac{1}{2} \\cdot \\frac{1}{4} = -\\frac{1}{4} - \\frac{1}{8} = -\\frac{3}{8}.\n\\]\n\nPara $ n = 2 $:\n\n\\[\nh[2] = \\frac{1}{4}\\delta[2] - \\frac{1}{4}\\delta[1] - \\frac{1}{2}h[1].\n\\]\nSustituyendo $ = 0 $, $ = 0 $, y $ h[1] = - $:\n\\[\nh[2] = -\\frac{1}{2} \\cdot \\left( -\\frac{3}{8} \\right) = \\frac{3}{16}.\n\\]\nLa secuencia resultante es una exponencial alternada decreciente debido al t칠rmino negativo recursivo $ -y[n-1] $.\nGeneralizaci칩n:\n\\[\nh[n] = \\frac{1}{4} \\left( -\\frac{1}{2} \\right)^n, \\; n \\geq 0.\n\\]\nAplicamos la Transformada de Fourier en Tiempo Discreto (TFTD) a la ecuaci칩n en diferencias. La respuesta en frecuencia se calcula como:\n\\[\nH(e^{j\\omega}) = \\frac{B(e^{j\\omega})}{A(e^{j\\omega})}.\n\\]\nDonde:\n- El numerador es $ B(z) = - z^{-1} $.\n- El denominador es $ A(z) = 1 + z^{-1} $.\nSustituyendo $ z = e^{j} $, obtenemos:\n\\[\nH(e^{j\\omega}) = \\frac{\\frac{1}{4} - \\frac{1}{4}e^{-j\\omega}}{1 + \\frac{1}{2}e^{-j\\omega}}.\n\\]\n\nMagnitud de $ H(e^{j}) $:\n\n\\[\n|H(e^{j\\omega})| = \\frac{\\left| \\frac{1}{4} - \\frac{1}{4}e^{-j\\omega} \\right|}{\\left| 1 + \\frac{1}{2}e^{-j\\omega} \\right|}.\n\\]\n\nFase de $ H(e^{j}) $:\n\n\\[\n\\angle H(e^{j\\omega}) = \\angle \\left( \\frac{\\frac{1}{4} - \\frac{1}{4}e^{-j\\omega}}{1 + \\frac{1}{2}e^{-j\\omega}} \\right).\n\\]\n\n# Respuesta impulsional h[n] - Sistema 4 (exponencial alternada decreciente)\nn = np.arange(0, 10)  # Instantes de tiempo\nh = (1 / 4) * (-1 / 2) ** n  # Respuesta impulsional anal칤tica\n\n# Respuesta en frecuencia H(e^jw)\nomega = np.linspace(-np.pi, np.pi, 1000)  # Frecuencias normalizadas\nnumerator = 0.25 - 0.25 * np.exp(-1j * omega)  # Numerador\ndenominator = 1 + 0.5 * np.exp(-1j * omega)    # Denominador\nH = numerator / denominator  # Respuesta en frecuencia\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H)\nphase = np.angle(H)\n\n# Graficar la respuesta impulsional\nplt.figure(figsize=(12, 8))\n\nplt.subplot(3, 1, 1)\nplt.stem(n, h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 4\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Graficar la magnitud de la respuesta en frecuencia\nplt.subplot(3, 1, 2)\nplt.plot(omega, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Graficar la fase de la respuesta en frecuencia\nplt.subplot(3, 1, 3)\nplt.plot(omega, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/04_y_output.html",
    "href": "notebooks/ejercicio1/04_y_output.html",
    "title": "Carga senal de entrada $ x[n] $",
    "section": "",
    "text": "Como se realiz칩 anteriormente, se selecciona una senal de entrada en base al numero de alumno, mediante la funci칩n load_signal\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Funci칩n para cargar la se침al desde el archivo CSV\ndef load_signal(case_number, base_path=\"data/signals\"):\n    \"\"\"\n    Carga una se침al desde un archivo CSV seg칰n el n칰mero de caso.\n\n    Par치metros:\n        case_number (int): N칰mero de caso (0, 1, 2, 3).\n        base_path (str): Ruta base donde se encuentran los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes n (0 hasta longitud de la se침al - 1).\n        x (numpy.ndarray): Valores de la se침al x[n].\n    \"\"\"\n    # Construir la ruta del archivo CSV\n    file_path = os.path.join(base_path, f\"case{case_number}.csv\")\n    \n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n    \n    # Cargar los valores de la se침al desde el archivo CSV\n    x = np.loadtxt(file_path, delimiter=\",\")\n    \n    # Generar los instantes n (0, 1, ..., len(x)-1)\n    n = np.arange(len(x))\n    \n    return n, x",
    "crumbs": [
      "Ejercicio 1",
      "Carga senal de entrada $ x[n] $"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/04_y_output.html#se-definen-los-sistemas",
    "href": "notebooks/ejercicio1/04_y_output.html#se-definen-los-sistemas",
    "title": "Carga senal de entrada $ x[n] $",
    "section": "Se definen los sistemas",
    "text": "Se definen los sistemas\nSe definen los sistemas como funciones.\n\nN es la longitud de la senal de entrada.\nse inicializa la salida y con ceros.\nse realiza una convolucion de forma iterativa\n\n\n# Definir las implementaciones de los sistemas (previamente implementados)\ndef sistema1(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.5 * x[n]\n        if n &gt; 0:\n            y[n] += 0.5 * x[n-1]\n    return y\n\ndef sistema2(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.5 * x[n]\n        if n &gt; 0:\n            y[n] -= 0.5 * x[n-1]\n    return y\n\ndef sistema3(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.25 * x[n]\n        if n &gt; 0:\n            y[n] += 0.25 * x[n-1]\n            y[n] += 0.5 * y[n-1]\n    return y\n\ndef sistema4(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.25 * x[n]\n        if n &gt; 0:\n            y[n] -= 0.25 * x[n-1]\n            y[n] -= 0.5 * y[n-1]\n    return y",
    "crumbs": [
      "Ejercicio 1",
      "Carga senal de entrada $ x[n] $"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/04_y_output.html#se-aplica-la-entrada-al-sistema",
    "href": "notebooks/ejercicio1/04_y_output.html#se-aplica-la-entrada-al-sistema",
    "title": "Carga senal de entrada $ x[n] $",
    "section": "Se aplica la entrada al sistema",
    "text": "Se aplica la entrada al sistema\nSe aplica la entrada $ x[n] $ en cada uno de los sistemas, y se grafican\n\n# N칰mero de alumno y selecci칩n de caso\nnum_al = 14253  # N칰mero de alumno\ncase_number = num_al % 4  # Determinar el n칰mero de caso\nprint(f\"El n칰mero de caso seleccionado es: {case_number}\")\n\n# Cargar la se침al correspondiente\nn, x = load_signal(case_number)\n\n# Aplicar los sistemas a la se침al de entrada\ny1 = sistema1(x)\ny2 = sistema2(x)\ny3 = sistema3(x)\ny4 = sistema4(x)\n\n# Graficar las se침ales de salida\nplt.figure(figsize=(12, 10))\n\n# Se침al de entrada\nplt.subplot(5, 1, 1)\nplt.stem(n, x, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(f\"Se침al de Entrada x[n] - Caso {case_number} para N칰mero de Alumno {num_al}\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"x[n]\")\nplt.grid()\n\n# Salida del Sistema 1\nplt.subplot(5, 1, 2)\nplt.stem(n, y1, basefmt=\" \", linefmt=\"g-\", markerfmt=\"go\")\nplt.title(\"Salida del Sistema 1\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y1[n]\")\nplt.grid()\n\n# Salida del Sistema 2\nplt.subplot(5, 1, 3)\nplt.stem(n, y2, basefmt=\" \", linefmt=\"r-\", markerfmt=\"ro\")\nplt.title(\"Salida del Sistema 2\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y2[n]\")\nplt.grid()\n\n# Salida del Sistema 3\nplt.subplot(5, 1, 4)\nplt.stem(n, y3, basefmt=\" \", linefmt=\"c-\", markerfmt=\"co\")\nplt.title(\"Salida del Sistema 3\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y3[n]\")\nplt.grid()\n\n# Salida del Sistema 4\nplt.subplot(5, 1, 5)\nplt.stem(n, y4, basefmt=\" \", linefmt=\"m-\", markerfmt=\"mo\")\nplt.title(\"Salida del Sistema 4\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y4[n]\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\nEl n칰mero de caso seleccionado es: 1\n\n\n\n\n\n\n\n\n\n\nConclusiones de las salidas\n\nSistema 1\nEl Sistema 1 es un filtro pasa bajas, de promedio movil de orden 1.\nLa salida obtenida suaviza la se침al de entrada. Se observa el patron de crecimiento de la se침al de entrada, pero menos oscilante. Esto se debe a que el valor de $ y[n] $ es el promedio ponderado de x[n] y x[n-1], lo cual atenua frecuencias altas.\n\n\nSistema 2\nEl Sistema 2 es un filtro pasa altas. La salida resalta los cambios bruscos de la senal de entrada. Aqui destaca la baja amplitud de la salida, en comparacion con los valores de entrada. Esto se debe a la diferencia entre valores consecutivos de $ x[n] $.\n\n\nSistema 3\nEl Sistema 3 es un filtro pasa bajas recursivo (con termino de retroalimentacion). Al igual que el Sistema 1, suaviza la senal de entrada.\n\n\nSistema 4\nEl Sistema 4 es un filtro pasa altas recursivo, con retroalimentacion negativa. Amplifica los cambios rapidos e introduce el efecto de alternancia.",
    "crumbs": [
      "Ejercicio 1",
      "Carga senal de entrada $ x[n] $"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/04_y_output.html#se-obtiene-la-tftd-de-las-salidas",
    "href": "notebooks/ejercicio1/04_y_output.html#se-obtiene-la-tftd-de-las-salidas",
    "title": "Carga senal de entrada $ x[n] $",
    "section": "Se obtiene la TFTD de las salidas",
    "text": "Se obtiene la TFTD de las salidas\nPara realizar un analisis del comportamiento de las frecuencias al aplicar los distintos sistemas, se aplica la TFTD a las salidas.\n\n# Calcular la TFTD de la se침al de entrada x[n]\nfft_x = np.fft.fft(x, n=512)  # FFT con cero-padding hasta 512 puntos\nfft_x_shifted = np.fft.fftshift(fft_x)  # Desplazar para centrar en 픨 = 0\n\n# Calcular la TFTD de las salidas\nfft_y1 = np.fft.fft(y1, n=512)\nfft_y2 = np.fft.fft(y2, n=512)\nfft_y3 = np.fft.fft(y3, n=512)\nfft_y4 = np.fft.fft(y4, n=512)\n\n# Frecuencias normalizadas\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Rango de - a \nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Desplazar las FFT para centrar en 픨 = 0\nfft_y1_shifted = np.fft.fftshift(fft_y1)\nfft_y2_shifted = np.fft.fftshift(fft_y2)\nfft_y3_shifted = np.fft.fftshift(fft_y3)\nfft_y4_shifted = np.fft.fftshift(fft_y4)\n\n# Graficar las respuestas en frecuencia\nplt.figure(figsize=(12, 12))\n\n# Magnitud de la TFTD - Se침al de Entrada\nplt.subplot(5, 1, 1)\nplt.plot(frequencies_shifted, np.abs(fft_x_shifted), color='k')\nplt.title(\"TFTD: Magnitud de la Se침al de Entrada $x[n]$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|X(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 1\nplt.subplot(5, 1, 2)\nplt.plot(frequencies_shifted, np.abs(fft_y1_shifted), color='b')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 1\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_1(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 2\nplt.subplot(5, 1, 3)\nplt.plot(frequencies_shifted, np.abs(fft_y2_shifted), color='g')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 2\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_2(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 3\nplt.subplot(5, 1, 4)\nplt.plot(frequencies_shifted, np.abs(fft_y3_shifted), color='r')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 3\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_3(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 4\nplt.subplot(5, 1, 5)\nplt.plot(frequencies_shifted, np.abs(fft_y4_shifted), color='m')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 4\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_4(e^{j\\omega})|$\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nEl primer grafico muestra el modulo de la TFTD de la senal de entrada $ x[n] $. Se observa un pico predominante en bajas frecuencias (cerca de $ = 0 $), lo cual indica que la senal tiene componentes de baja frecuencia elevadas.\nAdemas, se notan componentes de alta frecuencia cerca de $ $. Aunque la magnitud de estas frecuencias es mucho menor a las cercanas a cero, se observa un crecimiento notorio a medida que las frecuencias aumentan.\nLos Sistemas 1 y 3, mantienen el pico centrado en $ = 0 $ similar a la senal de entrada. Y en contraste con esta, las frecuencias altas han sido atenuadas, como se espera en filtros pasa bajos.\nLos Sistemas 2 y 4, en cambio, funcionan como filtros pasa altos y se observa que las frecuencias bajas, predominantes en la senal de entrada, se encuentran atenuadas casi por completo, y mantiene las frecuencias altas, que se pueden apreciar mejor en estos graficos debido al reescalado del eje de magnitud.",
    "crumbs": [
      "Ejercicio 1",
      "Carga senal de entrada $ x[n] $"
    ]
  },
  {
    "objectID": "notebooks/ejercicio2/01_h_system.html",
    "href": "notebooks/ejercicio2/01_h_system.html",
    "title": "hcanald.py",
    "section": "",
    "text": "import numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\ndef load_hcanal(num_al, base_path=\"data/signals\"):\n    \"\"\"\n    Selecciona y carga la respuesta impulsional del canal discreto desde el archivo CSV.\n\n    Par치metros:\n        num_al (int): N칰mero de alumno.\n        base_path (str): Ruta base donde se encuentran los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes n correspondientes a la respuesta impulsional.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n    \"\"\"\n    # Determinar el n칰mero de caso (num_al % 5)\n    case_number = num_al % 5\n    print(f\"El n칰mero de caso seleccionado es: {case_number}\")\n\n    # Construir la ruta del archivo CSV\n    file_name = f\"case{case_number}_clean.csv\"\n    file_path = os.path.join(base_path, file_name)\n\n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe. Verifique la ruta.\")\n\n    # Generar los instantes n (valores reales)\n    h = np.loadtxt(file_path, delimiter=\",\")\n    n = np.arange(len(h))  # 칈ndices reales de n en base a la longitud de h\n\n    return n, h\n\ndef plot_sparse_signal(n, h):\n    \"\"\"\n    Grafica una se침al mostrando solo los valores no nulos y usando puntos suspensivos.\n\n    Par치metros:\n        n (numpy.ndarray): Instantes de tiempo (valores reales del CSV).\n        h (numpy.ndarray): Respuesta impulsional (amplitud de la se침al).\n    \"\"\"\n    # Encontrar los 칤ndices donde h es no nulo\n    non_zero_indices = np.nonzero(h)[0]\n    \n    plt.figure(figsize=(12, 5))\n    \n    # Inicializar el gr치fico\n    last_index = -1  # Para manejar el primer tramo de ceros\n    for idx in non_zero_indices:\n        # Dibujar un tramo de ceros con puntos suspensivos si hay una separaci칩n grande\n        if last_index != -1 and (n[idx] &gt; n[last_index] + 1):\n            mid_point = (n[last_index] + n[idx]) / 2\n            plt.text(mid_point, 0, '...', ha='center', va='center', fontsize=34, fontweight='bold', color='blue')\n\n        # Dibujar el valor no nulo\n        plt.stem([n[idx]], [h[idx]], linefmt=\"b-\", markerfmt=\"bo\", basefmt=\" \")\n\n        # Actualizar el 칰ltimo 칤ndice no nulo\n        last_index = idx\n\n    # Configuraci칩n del gr치fico\n    plt.title(\"Respuesta Impulsional del Canal (Valores No Nulos Resaltados)\")\n    plt.xlabel(\"n (instantes)\")\n    plt.ylabel(\"h[n] (amplitud)\")\n    plt.grid()\n    plt.show()\n\n# N칰mero de alumno de entrada\nnum_al = 14253\n\n# Seleccionar y cargar la respuesta impulsional\nn, h = load_hcanal(num_al)\n \n# Mostrar informaci칩n b치sica\nprint(f\"Longitud de la respuesta impulsional: {len(h)}\")\nprint(f\"Primeros 10 valores de h: {h[:10]}\")\n\n# Graficar solo los valores no nulos\nplot_sparse_signal(n, h)\n\nEl n칰mero de caso seleccionado es: 3\nLongitud de la respuesta impulsional: 26460\nPrimeros 10 valores de h: [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\n\n\n\n\n\n\nLa funcion hcanald devuelve una respuesta impulsional $ h[n] $ que modela un canal digital de dos ecos.\nUn canal digital de dos ecos es un sistema que introduce dos versiones retardadas y atenuadas de la senal original. Estas versiones retardadas y atenuadas se denominan ecos.\nEl modelo matematico de un canal de dos ecos se puede modelar mediante una convolucion entre una senal de entrada $ x[n] $ y la respuesta impulsional del canal $ h[n] $.\n\\[\ny[n] = x[n] * h[n]\n\\]\nDonde $ h[n] $, la respuesta impulsional, tiene la siguiente forma:\n\\[\nh[n] = \\delta[n] + a_1 \\delta[n - d_1] + a_2 \\delta[n - d_2]\n\\]\n\n$ a_1 $: Atenuaci칩n del primer eco.\n$ d_1 $: Retardo del primer eco.\n$ a_2 $: Atenuaci칩n del segundo eco.\n$ d_2 $: Retardo del segundo eco.\n\nEl primer termino representa la senal original, que pasa sin retraso ni atenuacion.\nEl segundo y tercer termino representan el primer y segundo eco, respectivamente. Con su atenuacion $ a $ y restardo o delay $ d $\nUn canal digital de dos ecos es estable en el sentido BIBO, ya que su respuesta impulsional es finita y absolutamente sumable. Un sistema FIR siempre es estable porque su respuesta impulsional es finita y no incluye retroalimentaci칩n (depende solo de los valores actuales y pasados de la entrada).\nEntonces, para modelar un sistema con el comportamiento de la respuesta impulsional dada, se requieren los valores de atenuacion y retardo de cada uno de los ecos.\nEl siguiente script lee el archivo CSV con la respuesta impulsional $ h[n] $, identifica los valores no nulos y obtiene las amplitudes y los retardos de cada uno de los ecos.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\ndef load_hcanal(num_al, base_path=\"data/signals\"):\n    \"\"\"\n    Carga la respuesta impulsional del canal desde un archivo CSV.\n\n    Par치metros:\n        num_al (int): N칰mero de alumno.\n        base_path (str): Directorio base donde est치n los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n    \"\"\"\n    # Determinar el n칰mero de caso (num_al % 5)\n    case_number = num_al % 5\n    print(f\"El n칰mero de caso seleccionado es: {case_number}\")\n\n    # Ruta del archivo\n    file_name = f\"case{case_number}_clean.csv\"\n    file_path = os.path.join(base_path, file_name)\n\n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n\n    # Cargar la se침al desde el archivo\n    h = np.loadtxt(file_path, delimiter=\",\")\n    n = np.arange(len(h))\n\n    return n, h\n\ndef analyze_impulse_response(n, h):\n    \"\"\"\n    Analiza la respuesta impulsional y obtiene las amplitudes y retardos de los ecos.\n\n    Par치metros:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n\n    Retorna:\n        (a1, d1, a2, d2): Amplitudes y retardos de los dos ecos.\n    \"\"\"\n    # Encontrar los 칤ndices donde h[n] es no nulo\n    non_zero_indices = np.nonzero(h)[0]\n    non_zero_values = h[non_zero_indices]\n    \n    # Extraer valores\n    a0 = non_zero_values[0]  # Pico principal (valor unitario)\n    d0 = non_zero_indices[0]  # Pico principal\n    \n    a1 = non_zero_values[1]  # Amplitud del primer eco\n    d1 = non_zero_indices[1]  # Retardo del primer eco\n    \n    a2 = non_zero_values[2]  # Amplitud del segundo eco\n    d2 = non_zero_indices[2]  # Retardo del segundo eco\n    \n    print(\"Valores obtenidos de la respuesta impulsional:\")\n    print(f\"   Amplitud a1: {a1}, Retardo d1: {d1}\")\n    print(f\"   Amplitud a2: {a2}, Retardo d2: {d2}\")\n    \n    return a1, d1, a2, d2, non_zero_indices, non_zero_values\n\ndef plot_nonzero_impulse_response(n, h, a1, d1, a2, d2, indices, values):\n    \"\"\"\n    Grafica la respuesta impulsional mostrando solo los valores no nulos.\n\n    Par치metros:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n        indices (list): 칈ndices de los valores no nulos.\n        values (list): Valores de amplitud no nulos.\n    \"\"\"\n    plt.figure(figsize=(12, 5))\n    \n    # Graficar solo valores no nulos\n    plt.stem(indices, values, linefmt=\"b-\", markerfmt=\"bo\", basefmt=\" \")\n    \n    # Anotar los ecos detectados\n    plt.annotate(f\"Eco 1: a1={a1}, d1={d1}\", (d1, a1), textcoords=\"offset points\", xytext=(0,10), ha='center', color='red')\n    plt.annotate(f\"Eco 2: a2={a2}, d2={d2}\", (d2, a2), textcoords=\"offset points\", xytext=(0,10), ha='center', color='green')\n\n    # Configuraci칩n del gr치fico\n    plt.title(\"Respuesta Impulsional del Canal (Solo Valores No Nulos)\")\n    plt.xlabel(\"n (instantes)\")\n    plt.ylabel(\"h[n] (amplitud)\")\n    plt.grid()\n    plt.show()\n\n# Par치metros\nnum_al = 14253  # N칰mero de alumno\n\n# 1. Cargar la respuesta impulsional\nn, h = load_hcanal(num_al)\n\n# 2. Analizar la respuesta impulsional para obtener a1, d1, a2, d2\na1, d1, a2, d2, non_zero_indices, non_zero_values = analyze_impulse_response(n, h)\n\n# 3. Graficar solo los valores no nulos\nplot_nonzero_impulse_response(n, h, a1, d1, a2, d2, non_zero_indices, non_zero_values)\n\nEl n칰mero de caso seleccionado es: 3\nValores obtenidos de la respuesta impulsional:\n   Amplitud a1: -0.45, Retardo d1: 8820\n   Amplitud a2: 0.2025, Retardo d2: 17640\n\n\n\n\n\n\n\n\n\nUna vez creado el sistema de eco, se toma la senal de audio del archivo audio.wav. Al mismo, se le aplica la funcion implementada para obtener una senal de salida $ y[n] $.\nEl sistema esta dado por el doble eco:\n\n$ a1 = -0.45 $, retardo $ d1 = 8820 $.\n$ a2 = 0.2025 $, retardo $ d2 = 17640 $.\nFinalmente, se grafican la entrada y la salida del sistema.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.io import wavfile\n\n# 1. Funci칩n del sistema: Canal de doble eco\ndef double_echo_system(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica un canal de doble eco a la se침al de entrada.\n\n    Par치metros:\n        x (numpy.ndarray): Se침al de entrada.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n\n    Retorna:\n        y (numpy.ndarray): Se침al de salida con el canal de doble eco aplicado.\n    \"\"\"\n    N = len(x)  # Longitud de la se침al de entrada\n    y = np.zeros(N + d2)  # Crear salida con espacio suficiente para los retardos\n    \n    # Componente principal (sin retraso)\n    y[:N] += x\n    \n    # Primer eco\n    y[d1:N + d1] += a1 * x\n    \n    # Segundo eco\n    y[d2:N + d2] += a2 * x\n    \n    return y\n\n# 2. Cargar el archivo de audio\ndef load_audio(file_path):\n    \"\"\"\n    Carga una se침al de audio y la convierte a mono si es est칠reo.\n\n    Par치metros:\n        file_path (str): Ruta del archivo de audio.\n\n    Retorna:\n        fs (int): Frecuencia de muestreo.\n        x (numpy.ndarray): Se침al de audio en mono.\n    \"\"\"\n    fs, x = wavfile.read(file_path)  # Cargar archivo de audio\n    \n    # Si la se침al es est칠reo, convertir a mono\n    if len(x.shape) &gt; 1:\n        print(\"La se침al es est칠reo. Convirtiendo a mono...\")\n        x = np.mean(x, axis=1)  # Promedio de canales\n    \n    x = x.astype(float)  # Convertir a tipo float\n    return fs, x\n\n# 3. Graficar se침ales\ndef plot_input_output(x, y, fs):\n    \"\"\"\n    Grafica la se침al de entrada y salida.\n\n    Par치metros:\n        x (numpy.ndarray): Se침al de entrada.\n        y (numpy.ndarray): Se침al de salida.\n        fs (int): Frecuencia de muestreo.\n    \"\"\"\n    t_x = np.arange(len(x)) / fs  # Eje temporal de la se침al de entrada\n    t_y = np.arange(len(y)) / fs  # Eje temporal de la se침al de salida\n\n    plt.figure(figsize=(12, 6))\n\n    # Se침al de entrada\n    plt.subplot(2, 1, 1)\n    plt.plot(t_x, x, color='b')\n    plt.title(\"Se침al de Entrada x[n]\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Se침al de salida\n    plt.subplot(2, 1, 2)\n    plt.plot(t_y, y, color='g')\n    plt.title(\"Se침al de Salida y[n] (Canal de Doble Eco Aplicado)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    plt.tight_layout()\n    plt.show()\n\n# -----------------------------------------------\n# Par치metros\naudio_input = \"data/audio.wav\"  # Ruta del archivo de audio\na1, d1 = -0.45, 8820            # Amplitud y retardo del primer eco\na2, d2 = 0.2025, 17640          # Amplitud y retardo del segundo eco\n\n# 1. Cargar la se침al de entrada\nfs, x = load_audio(audio_input)\nprint(f\"Frecuencia de muestreo: {fs} Hz\")\nprint(f\"Longitud de la se침al de entrada: {len(x)} muestras\")\n\n# 2. Aplicar el sistema de doble eco\ny = double_echo_system(x, a1, d1, a2, d2)\nprint(f\"Longitud de la se침al de salida: {len(y)} muestras\")\n\n# 3. Graficar las se침ales\nplot_input_output(x, y, fs)\n\nLa se침al es est칠reo. Convirtiendo a mono...\nFrecuencia de muestreo: 48000 Hz\nLongitud de la se침al de entrada: 47668 muestras\nLongitud de la se침al de salida: 65308 muestras\n\n\n\n\n\n\n\n\n\n\nimport sounddevice as sd\n\ndef play_audio(signal, fs, description):\n    \"\"\"\n    Reproduce una se침al de audio.\n\n    Par치metros:\n        signal (numpy.ndarray): Se침al de audio.\n        fs (int): Frecuencia de muestreo.\n        description (str): Descripci칩n de la se침al para la consola.\n    \"\"\"\n    print(f\"Reproduciendo: {description}...\")\n    sd.play(signal, samplerate=fs)\n    sd.wait()  # Esperar hasta que termine la reproducci칩n\n    print(f\"Reproducci칩n de {description} completada.\\n\")\n\n# 1. Reproducir la se침al de entrada\nplay_audio(x, fs, \"Se침al de Entrada x[n]\")\n\n# 2. Reproducir la se침al de salida\nplay_audio(y, fs, \"Se침al de Salida y[n] (Canal de Doble Eco Aplicado)\")\n\nReproduciendo: Se침al de Entrada x[n]...\nReproducci칩n de Se침al de Entrada x[n] completada.\n\nReproduciendo: Se침al de Salida y[n] (Canal de Doble Eco Aplicado)...\nReproducci칩n de Se침al de Salida y[n] (Canal de Doble Eco Aplicado) completada.\n\n\n\nSe observa claramente la senal de entrada y la senal de salida con los dos ecos atenuados.\nPara compensar los ecos y que la senal filtrada sea lo mas cercana posible a la senal original, se implementara un filtro FIR que corrija la respuesta impulsional $ h[n] $ del canal de ecos.\nLa idea de implementar un sistema corrector FIR en cascada con el filtro de doble canal, es aproximar la respuesta impulsional total del sistema resultante a una unica delta de Kronecker\nSi la respuesta impulsional total se aproxima a una delta, significa que el sistema (canal + filtro) no introduce distorsion ni retardos en la senal de entrada.\nEl filtro corrige el canal al cancelar los ecos con retardos y atenuaciones opuestos al filtro original.\n\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.io import wavfile\n\n# 1. Funci칩n del sistema: Canal de doble eco\ndef double_echo_system(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica un canal de doble eco a la se침al de entrada.\n\n    Par치metros:\n        x (numpy.ndarray): Se침al de entrada.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n\n    Retorna:\n        y (numpy.ndarray): Se침al de salida con el canal de doble eco aplicado.\n    \"\"\"\n    N = len(x)  # Longitud de la se침al de entrada\n    y = np.zeros(N + d2)  # Crear salida con espacio suficiente para los retardos\n    \n    # Componente principal (sin retraso)\n    y[:N] += x\n    \n    # Primer eco\n    y[d1:N + d1] += a1 * x\n    \n    # Segundo eco\n    y[d2:N + d2] += a2 * x\n    \n    return y / np.max(np.abs(y))  # Normalizar para evitar desbordamiento\n\n# 2. Corregir la se침al con un filtro de 1 rama de retardo\ndef correct_signal_1r(x, a1, d1):\n    \"\"\"\n    Aplica una correcci칩n de 1 rama de retardo a la se침al de entrada.\n\n    Par치metros:\n        x (numpy.ndarray): Se침al de entrada.\n        a1 (float): Amplitud de la primera correcci칩n.\n        d1 (int): Retardo de la primera correcci칩n.\n\n    Retorna:\n        y (numpy.ndarray): Se침al corregida.\n    \"\"\"\n    y = x.copy()\n    y[d1:] -= a1 * y[:-d1]  # Corregir el eco\n    return y\n\n# 3. Corregir la se침al con un filtro de 2 ramas de retardo\ndef correct_signal_2r(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica una correcci칩n de 2 ramas de retardo a la se침al de entrada.\n\n    Par치metros:\n        x (numpy.ndarray): Se침al de entrada.\n        a1 (float): Amplitud de la primera correcci칩n.\n        d1 (int): Retardo de la primera correcci칩n.\n        a2 (float): Amplitud de la segunda correcci칩n.\n        d2 (int): Retardo de la segunda correcci칩n.\n\n    Retorna:\n        y (numpy.ndarray): Se침al corregida.\n    \"\"\"\n    y = x.copy()\n    y[d1:] -= a1 * y[:-d1]  # Corregir primer eco\n    y[d2:] -= a2 * y[:-d2]  # Corregir segundo eco\n    return y\n\n# 4. Cargar el archivo de audio\ndef load_audio(file_path):\n    \"\"\"\n    Carga una se침al de audio y la convierte a mono si es est칠reo.\n\n    Par치metros:\n        file_path (str): Ruta del archivo de audio.\n\n    Retorna:\n        fs (int): Frecuencia de muestreo.\n        x (numpy.ndarray): Se침al de audio en mono.\n    \"\"\"\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n    \n    fs, x = wavfile.read(file_path)  # Cargar archivo de audio\n    \n    # Si la se침al es est칠reo, convertir a mono\n    if len(x.shape) &gt; 1:\n        print(\"La se침al es est칠reo. Convirtiendo a mono...\")\n        x = np.mean(x, axis=1)  # Promedio de canales\n    \n    x = x.astype(float)  # Convertir a tipo float\n    return fs, x\n\n# 5. Graficar se침ales\ndef plot_signals(x, y_echo, y_corr1, y_corr2, fs):\n    \"\"\"\n    Grafica las se침ales de entrada, con ecos y las corregidas.\n\n    Par치metros:\n        x (numpy.ndarray): Se침al de entrada.\n        y_echo (numpy.ndarray): Se침al con ecos.\n        y_corr1 (numpy.ndarray): Se침al corregida (1 rama de retardo).\n        y_corr2 (numpy.ndarray): Se침al corregida (2 ramas de retardo).\n        fs (int): Frecuencia de muestreo.\n    \"\"\"\n    t_x = np.arange(len(x)) / fs  # Eje temporal de la se침al de entrada\n    t_y = np.arange(len(y_echo)) / fs  # Eje temporal de las se침ales de salida\n\n    plt.figure(figsize=(12, 12))\n\n    # Se침al de entrada original\n    plt.subplot(4, 1, 1)\n    plt.plot(t_x, x, color='b')\n    plt.title(\"Se침al Original x[n]\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Se침al con ecos\n    plt.subplot(4, 1, 2)\n    plt.plot(t_y, y_echo, color='g')\n    plt.title(\"Se침al con Ecos y[n] (Canal de Doble Eco)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Se침al corregida con 1 rama de retardo\n    plt.subplot(4, 1, 3)\n    plt.plot(t_y, y_corr1, color='r')\n    plt.title(\"Se침al Corregida (Filtro con 1 Rama de Retardo)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Se침al corregida con 2 ramas de retardo\n    plt.subplot(4, 1, 4)\n    plt.plot(t_y, y_corr2, color='m')\n    plt.title(\"Se침al Corregida (Filtro con 2 Ramas de Retardo)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    plt.tight_layout()\n    plt.show()\n\n# -----------------------------------------------\n# Par치metros\naudio_input = \"data/audio.wav\"  # Ruta del archivo de audio\na1, d1 = -0.45, 8820            # Amplitud y retardo del primer eco\na2, d2 = 0.2025, 17640          # Amplitud y retardo del segundo eco\n\n# 1. Cargar la se침al de entrada\nfs, x = load_audio(audio_input)\nprint(f\"Frecuencia de muestreo: {fs} Hz\")\nprint(f\"Longitud de la se침al de entrada: {len(x)} muestras\")\n\n# 2. Aplicar el sistema de doble eco\ny_echo = double_echo_system(x, a1, d1, a2, d2)\n\n# 3. Corregir la se침al\ny_corr1 = correct_signal_1r(y_echo, a1, d1)\ny_corr2 = correct_signal_2r(y_echo, a1, d1, a2, d2)\n\n# 4. Graficar todas las se침ales\nplot_signals(x, y_echo, y_corr1, y_corr2, fs)\n\nLa se침al es est칠reo. Convirtiendo a mono...\nFrecuencia de muestreo: 48000 Hz\nLongitud de la se침al de entrada: 47668 muestras",
    "crumbs": [
      "Ejercicio 2",
      "`hcanald.py`"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pr치ctica con Utilitario - IPS 2024",
    "section": "",
    "text": "Autor: Gian Franco Lasala - 01425/3\nEn esta p치gina encontrar치s una breve explicaci칩n sobre Quarto y Binder, adem치s de los enlaces a los ejercicios resueltos."
  },
  {
    "objectID": "index.html#qu칠-es-quarto",
    "href": "index.html#qu칠-es-quarto",
    "title": "Pr치ctica con Utilitario - IPS 2024",
    "section": "1 쯈u칠 es Quarto?",
    "text": "1 쯈u칠 es Quarto?\nQuarto es una herramienta de c칩digo abierto que permite crear documentos, sitios web, libros y presentaciones interactivas a partir de archivos Markdown (.qmd) y Jupyter Notebooks (.ipynb).\nQuarto se utiliza para generar contenido din치mico y reproducible, especialmente 칰til en ciencia de datos y ense침anza."
  },
  {
    "objectID": "index.html#qu칠-es-binder",
    "href": "index.html#qu칠-es-binder",
    "title": "Pr치ctica con Utilitario - IPS 2024",
    "section": "2 쯈u칠 es Binder?",
    "text": "2 쯈u칠 es Binder?\nBinder es un servicio gratuito que permite ejecutar notebooks interactivos directamente en la nube. Simplemente, seleccionas un repositorio de GitHub que contenga tus archivos y Binder proporciona un entorno ejecutable en tiempo real.\nBinder es ideal para compartir proyectos interactivos sin necesidad de configuraciones locales."
  },
  {
    "objectID": "index.html#ejecuta-los-ejercicios-con-binder",
    "href": "index.html#ejecuta-los-ejercicios-con-binder",
    "title": "Pr치ctica con Utilitario - IPS 2024",
    "section": "3 Ejecuta los Ejercicios con Binder 游",
    "text": "3 Ejecuta los Ejercicios con Binder 游\nHaz clic en el siguiente bot칩n para abrir este proyecto en Binder y ejecutarlo en un entorno interactivo:\n\n\n\nLaunch Binder"
  },
  {
    "objectID": "index.html#ejercicios-resueltos",
    "href": "index.html#ejercicios-resueltos",
    "title": "Pr치ctica con Utilitario - IPS 2024",
    "section": "4 Ejercicios Resueltos",
    "text": "4 Ejercicios Resueltos\nA continuaci칩n, encontrar치s los enlaces a los ejercicios resueltos:\n\n4.1 Ejercicio 1\n\nSe침al de Entrada\nRespuesta Impulsional del Sistema\nAn치lisis Num칠rico del Sistema\nSalida del Sistema\n\n\n\n4.2 Ejercicio 2\n\nRespuesta Impulsional del Canal"
  },
  {
    "objectID": "index.html#accede-a-la-versi칩n-est치tica",
    "href": "index.html#accede-a-la-versi칩n-est치tica",
    "title": "Pr치ctica con Utilitario - IPS 2024",
    "section": "5 Accede a la Versi칩n Est치tica",
    "text": "5 Accede a la Versi칩n Est치tica\nSi prefieres acceder al sitio web est치tico, puedes visitar el siguiente enlace:\nVersi칩n Est치tica"
  },
  {
    "objectID": "index.html#repositorio-del-proyecto",
    "href": "index.html#repositorio-del-proyecto",
    "title": "Pr치ctica con Utilitario - IPS 2024",
    "section": "6 Repositorio del Proyecto",
    "text": "6 Repositorio del Proyecto\nEl c칩digo fuente de este proyecto est치 disponible en el siguiente repositorio de GitHub:\nRepositorio GitHub"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html",
    "href": "notebooks/ejercicio1/03_h_systems_num.html",
    "title": "Sistemas: resolucion numerica",
    "section": "",
    "text": "Para implementar los sistemas discretos, calcular la respuesta impulsional y aplicar la Transformada de Fourier en Tiempo Discreto (TFTD), se utilizan las siguientes librer칤as y funciones de Python:\n\nNumPy es fundamental para realizar c치lculos num칠ricos en Python.\n\nMatplotlib se utiliza para graficar los resultados obtenidos. Permite visualizar tanto se침ales en el dominio del tiempo como en el dominio de la frecuencia.\nnp.zeros(N): Crea un arreglo de ceros con $ N $ elementos.\n\nnp.arange(start, stop): Crea una secuencia de n칰meros entre start y stop.\n\nnp.convolve(x, h, mode): Realiza la convoluci칩n entre dos se침ales.\n\nnp.fft.fft(h): Calcula la Transformada de Fourier de la se침al $ h $.\n\nnp.fft.fftfreq(N, d): Devuelve las frecuencias correspondientes a la FFT.\nplt.stem(x, y): Grafica una se침al discreta.\n\nplt.plot(x, y): Grafica una se침al continua o en el dominio de la frecuencia.\n\nplt.title(), plt.xlabel(), plt.ylabel(): A침aden t칤tulos y etiquetas a los gr치ficos.\n\nplt.grid(): Activa la cuadr칤cula en el gr치fico.\n\nSe utilizan funciones personalizadas para implementar cada uno de los sistemas en forma de convoluci칩n. Cada sistema ser치 una funci칩n que recibir치 una se침al de entrada $ x[n] $ y devolver치 la se침al de salida $ y[n] $.\nM칠todo:\n- La respuesta de cada sistema se obtiene utilizando la convoluci칩n entre la entrada $ x[n] $ y la respuesta impulsional $ h[n] $.\n- Se aplicar치 la TFTD (mediante np.fft.fft) a la respuesta impulsional para verificar que coincide con la respuesta en frecuencia anal칤tica.",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html#librerias",
    "href": "notebooks/ejercicio1/03_h_systems_num.html#librerias",
    "title": "Sistemas: resolucion numerica",
    "section": "",
    "text": "Para implementar los sistemas discretos, calcular la respuesta impulsional y aplicar la Transformada de Fourier en Tiempo Discreto (TFTD), se utilizan las siguientes librer칤as y funciones de Python:\n\nNumPy es fundamental para realizar c치lculos num칠ricos en Python.\n\nMatplotlib se utiliza para graficar los resultados obtenidos. Permite visualizar tanto se침ales en el dominio del tiempo como en el dominio de la frecuencia.\nnp.zeros(N): Crea un arreglo de ceros con $ N $ elementos.\n\nnp.arange(start, stop): Crea una secuencia de n칰meros entre start y stop.\n\nnp.convolve(x, h, mode): Realiza la convoluci칩n entre dos se침ales.\n\nnp.fft.fft(h): Calcula la Transformada de Fourier de la se침al $ h $.\n\nnp.fft.fftfreq(N, d): Devuelve las frecuencias correspondientes a la FFT.\nplt.stem(x, y): Grafica una se침al discreta.\n\nplt.plot(x, y): Grafica una se침al continua o en el dominio de la frecuencia.\n\nplt.title(), plt.xlabel(), plt.ylabel(): A침aden t칤tulos y etiquetas a los gr치ficos.\n\nplt.grid(): Activa la cuadr칤cula en el gr치fico.\n\nSe utilizan funciones personalizadas para implementar cada uno de los sistemas en forma de convoluci칩n. Cada sistema ser치 una funci칩n que recibir치 una se침al de entrada $ x[n] $ y devolver치 la se침al de salida $ y[n] $.\nM칠todo:\n- La respuesta de cada sistema se obtiene utilizando la convoluci칩n entre la entrada $ x[n] $ y la respuesta impulsional $ h[n] $.\n- Se aplicar치 la TFTD (mediante np.fft.fft) a la respuesta impulsional para verificar que coincide con la respuesta en frecuencia anal칤tica.",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html#sistema-1",
    "href": "notebooks/ejercicio1/03_h_systems_num.html#sistema-1",
    "title": "Sistemas: resolucion numerica",
    "section": "Sistema 1",
    "text": "Sistema 1\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Funci칩n que implementa el Sistema 1\ndef sistema1(x):\n    \"\"\"\n    Implementa el sistema 1: y[n] = 0.5*x[n] + 0.5*x[n-1]\n    Entrada: x -&gt; Se침al de entrada\n    Salida: y -&gt; Se침al de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.5 * x[n]  # Primer t칠rmino\n        if n &gt; 0:\n            y[n] += 0.5 * x[n-1]  # Segundo t칠rmino (desplazado)\n    return y\n\n# Generar la se침al de entrada: impulso unitario 풦[n]\nN = 20  # Duraci칩n de la se침al\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema1(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos para mayor resoluci칩n\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre - y \nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en 픨 = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 1\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html#sistema-2",
    "href": "notebooks/ejercicio1/03_h_systems_num.html#sistema-2",
    "title": "Sistemas: resolucion numerica",
    "section": "Sistema 2",
    "text": "Sistema 2\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Funci칩n que implementa el Sistema 2\ndef sistema2(x):\n    \"\"\"\n    Implementa el sistema 2: y[n] = 0.5*x[n] - 0.5*x[n-1]\n    Entrada: x -&gt; Se침al de entrada\n    Salida: y -&gt; Se침al de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.5 * x[n]  # Primer t칠rmino\n        if n &gt; 0:\n            y[n] -= 0.5 * x[n-1]  # Segundo t칠rmino (desplazado y restado)\n    return y\n\n# Generar la se침al de entrada: impulso unitario 풦[n]\nN = 20  # Duraci칩n de la se침al\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema2(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre - y \nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en 픨 = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 2\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/03_h_systems_num.html#sistema-3",
    "href": "notebooks/ejercicio1/03_h_systems_num.html#sistema-3",
    "title": "Sistemas: resolucion numerica",
    "section": "Sistema 3",
    "text": "Sistema 3\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Funci칩n que implementa el Sistema 3\ndef sistema3(x):\n    \"\"\"\n    Implementa el sistema 3: y[n] = 0.25*x[n] + 0.25*x[n-1] + 0.5*y[n-1]\n    Entrada: x -&gt; Se침al de entrada\n    Salida: y -&gt; Se침al de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.25 * x[n]  # Primer t칠rmino\n        if n &gt; 0:\n            y[n] += 0.25 * x[n-1]  # Segundo t칠rmino (desplazado)\n            y[n] += 0.5 * y[n-1]   # T칠rmino recursivo\n    return y\n\n# Generar la se침al de entrada: impulso unitario 풦[n]\nN = 20  # Duraci칩n de la se침al\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema3(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre - y \nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en 픨 = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 3\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Funci칩n que implementa el Sistema 4\ndef sistema4(x):\n    \"\"\"\n    Implementa el sistema 4: y[n] = 0.25*x[n] - 0.25*x[n-1] - 0.5*y[n-1]\n    Entrada: x -&gt; Se침al de entrada\n    Salida: y -&gt; Se침al de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.25 * x[n]  # Primer t칠rmino\n        if n &gt; 0:\n            y[n] -= 0.25 * x[n-1]  # Segundo t칠rmino (desplazado y restado)\n            y[n] -= 0.5 * y[n-1]   # T칠rmino recursivo (negativo)\n    return y\n\n# Generar la se침al de entrada: impulso unitario 풦[n]\nN = 20  # Duraci칩n de la se침al\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema4(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre - y \nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en 픨 = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 4\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Ejercicio 1",
      "Sistemas: resolucion numerica"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/01_x_input.html",
    "href": "notebooks/ejercicio1/01_x_input.html",
    "title": "1.1 Se침al Discreta",
    "section": "",
    "text": "En esta secci칩n, se genera la se침al discreta $ x[n] $, se grafica y analiza sus componentes de frecuencia mediante la Transformada de Fourier Discreta (TFTD).",
    "crumbs": [
      "Ejercicio 1",
      "**1.1 Se침al Discreta**"
    ]
  },
  {
    "objectID": "notebooks/ejercicio1/01_x_input.html#sistemas-discretos",
    "href": "notebooks/ejercicio1/01_x_input.html#sistemas-discretos",
    "title": "1.1 Se침al Discreta",
    "section": "Sistemas Discretos",
    "text": "Sistemas Discretos\nSe dan sistemas est치n definidos por las siguientes ecuaciones en diferencias:\n\nSistema 1:\n\\[\ny[n] = \\frac{1}{2}x[n] + \\frac{1}{2}x[n-1]\n\\]\nSistema 2:\n$$ y[n] = x[n] - x[n-1]\n$$\nSistema 3:\n\\[\ny[n] = \\frac{1}{4}x[n] + \\frac{1}{4}x[n-1] + \\frac{1}{2}y[n-1]\n\\]\nSistema 4:\n\\[\ny[n] = \\frac{1}{4}x[n] - \\frac{1}{4}x[n-1] - \\frac{1}{2}y[n-1]\n\\]",
    "crumbs": [
      "Ejercicio 1",
      "**1.1 Se침al Discreta**"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html",
    "href": "notebooks/librerias/librerias.html",
    "title": "Librerias",
    "section": "",
    "text": "Prop칩sito: Manipulaci칩n eficiente de matrices y operaciones matem치ticas fundamentales.\nFunciones clave:\n- np.arange()\n- Genera arreglos de valores equiespaciados.\n- Ejemplo: Generar instantes de tiempo para se침ales: n = np.arange(0, N)\n- np.zeros()\n- Crea arreglos inicializados con ceros.\n- Ejemplo: y = np.zeros(N) para inicializar una se침al.\n- np.fft.fft()\n- Calcula la Transformada de Fourier Discreta (TFTD) de una se침al.\n- Ejemplo: fft_x = np.fft.fft(x)\n- np.fft.fftfreq()\n- Calcula las frecuencias correspondientes a la FFT.\n- Ejemplo: frequencies = np.fft.fftfreq(N, d=1/fs)\n- np.fft.fftshift()\n- Desplaza las frecuencias centrando en ( = 0 ).\n- Ejemplo: fft_shifted = np.fft.fftshift(fft_x)\n- np.convolve()\n- Realiza la convoluci칩n entre dos se침ales.\n- Ejemplo: y = np.convolve(x, h, mode='full')\n\n\n\n\nProp칩sito: Visualizaci칩n de se침ales en el dominio del tiempo y frecuencia.\nFunciones clave:\n- plt.plot()\n- Grafica una se침al continua.\n- Ejemplo: plt.plot(t, x)\n- plt.stem()\n- Grafica se침ales discretas (en puntos).\n- Ejemplo: plt.stem(n, x)\n- plt.title(), plt.xlabel(), plt.ylabel()\n- Personalizan t칤tulos y etiquetas de gr치ficos.\n- Ejemplo: plt.title(\"Se침al x[n]\")\n- plt.grid()\n- Activa una cuadr칤cula en el gr치fico.\n- Ejemplo: plt.grid(True)\n- plt.tight_layout()\n- Ajusta autom치ticamente la distribuci칩n de los subgr치ficos.\n- plt.show()\n- Muestra los gr치ficos.\n\n\n\n\nProp칩sito: Procesamiento avanzado de se침ales, an치lisis de sistemas LTI.\nSubm칩dulo clave: scipy.signal\nFunciones clave:\n- signal.dlti()\n- Representa sistemas LTI (Lineales e Invariantes en el Tiempo) en tiempo discreto.\n- Ejemplo: system = signal.dlti(b, a)\n- signal.dimpulse()\n- Calcula la respuesta impulsional de un sistema LTI discreto.\n- Ejemplo: t, h = signal.dimpulse(system, n=20)\n- signal.lfilter()\n- Aplica un filtro FIR o IIR a una se침al.\n- Ejemplo: y = signal.lfilter(b, a, x)\n- signal.firwin()\n- Dise침a filtros FIR con caracter칤sticas espec칤ficas.\n- Ejemplo: Crear un filtro pasa bajos: b = signal.firwin(N, cutoff)\n- signal.freqz()\n- Calcula y grafica la respuesta en frecuencia de un sistema.\n- Ejemplo: w, h = signal.freqz(b, a, worN=512)\n\n\n\n\nProp칩sito: Lectura y escritura de archivos de audio.\nFunciones clave:\n- sf.read()\n- Carga archivos de audio (wav, flac, etc.).\n- Ejemplo: fs, x = sf.read('audio.wav')\n- sf.write()\n- Guarda una se침al en un archivo de audio.\n- Ejemplo: sf.write('output.wav', y, fs)\n\n\n\n\nProp칩sito: Entorno interactivo para la ejecuci칩n de c칩digo y visualizaci칩n.\nHerramientas clave:\n- IPython.display.Audio()\n- Reproduce una se침al de audio en una celda de Jupyter.\n- Ejemplo: Audio(y, rate=fs)\n- Markdown y LaTeX:\n- Documentaci칩n de reportes, uso de f칩rmulas matem치ticas.\n- Ejemplo: $$ y[n] = x[n] * h[n] $$\n\n\n\n\nProp칩sito: Ejecutar scripts de Octave/MATLAB desde Python.\nFunciones clave:\n- Oct2Py()\n- Inicializa una sesi칩n de Octave.\n- Ejemplo: oc = Oct2Py()\n- oc.run()\n- Ejecuta scripts de Octave.\n- Ejemplo: oc.run('hcanald.m')\n- oc.addpath()\n- Agrega rutas a carpetas que contienen archivos Octave/MATLAB.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html#librer칤as-utilizadas",
    "href": "notebooks/librerias/librerias.html#librer칤as-utilizadas",
    "title": "Librerias",
    "section": "",
    "text": "Prop칩sito: Manipulaci칩n eficiente de matrices y operaciones matem치ticas fundamentales.\nFunciones clave:\n- np.arange()\n- Genera arreglos de valores equiespaciados.\n- Ejemplo: Generar instantes de tiempo para se침ales: n = np.arange(0, N)\n- np.zeros()\n- Crea arreglos inicializados con ceros.\n- Ejemplo: y = np.zeros(N) para inicializar una se침al.\n- np.fft.fft()\n- Calcula la Transformada de Fourier Discreta (TFTD) de una se침al.\n- Ejemplo: fft_x = np.fft.fft(x)\n- np.fft.fftfreq()\n- Calcula las frecuencias correspondientes a la FFT.\n- Ejemplo: frequencies = np.fft.fftfreq(N, d=1/fs)\n- np.fft.fftshift()\n- Desplaza las frecuencias centrando en ( = 0 ).\n- Ejemplo: fft_shifted = np.fft.fftshift(fft_x)\n- np.convolve()\n- Realiza la convoluci칩n entre dos se침ales.\n- Ejemplo: y = np.convolve(x, h, mode='full')\n\n\n\n\nProp칩sito: Visualizaci칩n de se침ales en el dominio del tiempo y frecuencia.\nFunciones clave:\n- plt.plot()\n- Grafica una se침al continua.\n- Ejemplo: plt.plot(t, x)\n- plt.stem()\n- Grafica se침ales discretas (en puntos).\n- Ejemplo: plt.stem(n, x)\n- plt.title(), plt.xlabel(), plt.ylabel()\n- Personalizan t칤tulos y etiquetas de gr치ficos.\n- Ejemplo: plt.title(\"Se침al x[n]\")\n- plt.grid()\n- Activa una cuadr칤cula en el gr치fico.\n- Ejemplo: plt.grid(True)\n- plt.tight_layout()\n- Ajusta autom치ticamente la distribuci칩n de los subgr치ficos.\n- plt.show()\n- Muestra los gr치ficos.\n\n\n\n\nProp칩sito: Procesamiento avanzado de se침ales, an치lisis de sistemas LTI.\nSubm칩dulo clave: scipy.signal\nFunciones clave:\n- signal.dlti()\n- Representa sistemas LTI (Lineales e Invariantes en el Tiempo) en tiempo discreto.\n- Ejemplo: system = signal.dlti(b, a)\n- signal.dimpulse()\n- Calcula la respuesta impulsional de un sistema LTI discreto.\n- Ejemplo: t, h = signal.dimpulse(system, n=20)\n- signal.lfilter()\n- Aplica un filtro FIR o IIR a una se침al.\n- Ejemplo: y = signal.lfilter(b, a, x)\n- signal.firwin()\n- Dise침a filtros FIR con caracter칤sticas espec칤ficas.\n- Ejemplo: Crear un filtro pasa bajos: b = signal.firwin(N, cutoff)\n- signal.freqz()\n- Calcula y grafica la respuesta en frecuencia de un sistema.\n- Ejemplo: w, h = signal.freqz(b, a, worN=512)\n\n\n\n\nProp칩sito: Lectura y escritura de archivos de audio.\nFunciones clave:\n- sf.read()\n- Carga archivos de audio (wav, flac, etc.).\n- Ejemplo: fs, x = sf.read('audio.wav')\n- sf.write()\n- Guarda una se침al en un archivo de audio.\n- Ejemplo: sf.write('output.wav', y, fs)\n\n\n\n\nProp칩sito: Entorno interactivo para la ejecuci칩n de c칩digo y visualizaci칩n.\nHerramientas clave:\n- IPython.display.Audio()\n- Reproduce una se침al de audio en una celda de Jupyter.\n- Ejemplo: Audio(y, rate=fs)\n- Markdown y LaTeX:\n- Documentaci칩n de reportes, uso de f칩rmulas matem치ticas.\n- Ejemplo: $$ y[n] = x[n] * h[n] $$\n\n\n\n\nProp칩sito: Ejecutar scripts de Octave/MATLAB desde Python.\nFunciones clave:\n- Oct2Py()\n- Inicializa una sesi칩n de Octave.\n- Ejemplo: oc = Oct2Py()\n- oc.run()\n- Ejecuta scripts de Octave.\n- Ejemplo: oc.run('hcanald.m')\n- oc.addpath()\n- Agrega rutas a carpetas que contienen archivos Octave/MATLAB.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html#procesamiento-de-se침ales-utilizado",
    "href": "notebooks/librerias/librerias.html#procesamiento-de-se침ales-utilizado",
    "title": "Librerias",
    "section": "Procesamiento de Se침ales Utilizado",
    "text": "Procesamiento de Se침ales Utilizado\n\n1. Respuesta Impulsional ( h[n] )\nLa respuesta impulsional de un sistema fue calculada usando: - An치lisis manual de las ecuaciones en diferencias.\n- Implementaci칩n con scipy.signal.dimpulse.\n- Graficada usando matplotlib.stem().\n\n\n2. Transformada de Fourier en Tiempo Discreto (TFTD)\n\nCalculada usando np.fft.fft.\n\nFrecuencias generadas con np.fft.fftfreq y desplazadas con np.fft.fftshift.\n\nMagnitud y fase de la se침al graficadas para an치lisis.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html#filtros-implementados",
    "href": "notebooks/librerias/librerias.html#filtros-implementados",
    "title": "Librerias",
    "section": "Filtros Implementados",
    "text": "Filtros Implementados\n\n1. Sistemas LTI FIR\nFiltros implementados en base a las ecuaciones en diferencias dadas.\n- Usamos convoluci칩n (np.convolve) para aplicar la respuesta impulsional.\n- Ejemplo: Canal con doble eco.\n\n\n2. Filtros Correctores\n\nFiltro FIR de 1 rama de retardo: Atenuaci칩n de un solo eco.\n\nFiltro FIR de 2 ramas de retardo: Correcci칩n de dos ecos simult치neamente.\n\nAmbos implementados utilizando np.convolve() y analizados en el tiempo y frecuencia.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  },
  {
    "objectID": "notebooks/librerias/librerias.html#procesamiento-de-audio",
    "href": "notebooks/librerias/librerias.html#procesamiento-de-audio",
    "title": "Librerias",
    "section": "Procesamiento de Audio",
    "text": "Procesamiento de Audio\n\nCargado y guardado con soundfile.\n\nVisualizaci칩n en tiempo usando matplotlib.\n\nAn치lisis en frecuencia usando la TFTD.\n\nReproducci칩n de audio en Jupyter con IPython.display.Audio.",
    "crumbs": [
      "Librerias",
      "Librerias"
    ]
  }
]