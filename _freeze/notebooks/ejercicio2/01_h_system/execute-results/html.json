{
  "hash": "26b8b893668cd40c0fa89b2b170d967b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: '`hcanald.py`'\njupyter: python3\n---\n\n::: {#f6cbc1d1 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\ndef load_hcanal(num_al, base_path=\"data/signals\"):\n    \"\"\"\n    Selecciona y carga la respuesta impulsional del canal discreto desde el archivo CSV.\n\n    Parámetros:\n        num_al (int): Número de alumno.\n        base_path (str): Ruta base donde se encuentran los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes n correspondientes a la respuesta impulsional.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n    \"\"\"\n    # Determinar el número de caso (num_al % 5)\n    case_number = num_al % 5\n    print(f\"El número de caso seleccionado es: {case_number}\")\n\n    # Construir la ruta del archivo CSV\n    file_name = f\"case{case_number}_clean.csv\"\n    file_path = os.path.join(base_path, file_name)\n\n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe. Verifique la ruta.\")\n\n    # Generar los instantes n (valores reales)\n    h = np.loadtxt(file_path, delimiter=\",\")\n    n = np.arange(len(h))  # Índices reales de n en base a la longitud de h\n\n    return n, h\n\ndef plot_sparse_signal(n, h):\n    \"\"\"\n    Grafica una señal mostrando solo los valores no nulos y usando puntos suspensivos.\n\n    Parámetros:\n        n (numpy.ndarray): Instantes de tiempo (valores reales del CSV).\n        h (numpy.ndarray): Respuesta impulsional (amplitud de la señal).\n    \"\"\"\n    # Encontrar los índices donde h es no nulo\n    non_zero_indices = np.nonzero(h)[0]\n    \n    plt.figure(figsize=(12, 5))\n    \n    # Inicializar el gráfico\n    last_index = -1  # Para manejar el primer tramo de ceros\n    for idx in non_zero_indices:\n        # Dibujar un tramo de ceros con puntos suspensivos si hay una separación grande\n        if last_index != -1 and (n[idx] > n[last_index] + 1):\n            mid_point = (n[last_index] + n[idx]) / 2\n            plt.text(mid_point, 0, '...', ha='center', va='center', fontsize=34, fontweight='bold', color='blue')\n\n        # Dibujar el valor no nulo\n        plt.stem([n[idx]], [h[idx]], linefmt=\"b-\", markerfmt=\"bo\", basefmt=\" \")\n\n        # Actualizar el último índice no nulo\n        last_index = idx\n\n    # Configuración del gráfico\n    plt.title(\"Respuesta Impulsional del Canal (Valores No Nulos Resaltados)\")\n    plt.xlabel(\"n (instantes)\")\n    plt.ylabel(\"h[n] (amplitud)\")\n    plt.grid()\n    plt.show()\n\n# Número de alumno de entrada\nnum_al = 14253\n\n# Seleccionar y cargar la respuesta impulsional\nn, h = load_hcanal(num_al)\n \n# Mostrar información básica\nprint(f\"Longitud de la respuesta impulsional: {len(h)}\")\nprint(f\"Primeros 10 valores de h: {h[:10]}\")\n\n# Graficar solo los valores no nulos\nplot_sparse_signal(n, h)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEl número de caso seleccionado es: 3\nLongitud de la respuesta impulsional: 26460\nPrimeros 10 valores de h: [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](01_h_system_files/figure-html/cell-2-output-2.png){width=972 height=449}\n:::\n:::\n\n\nLa funcion `hcanald` devuelve una respuesta impulsional $ h[n] $ que modela un canal digital de **dos ecos**.\n\nUn **canal digital de dos ecos** es un sistema que introduce **dos versiones retardadas y atenuadas** de la senal original. Estas versiones retardadas y atenuadas se denominan **ecos**.\n\nEl modelo matematico de un canal de dos ecos se puede modelar mediante una **convolucion** entre una senal de entrada $ x[n] $ y la **respuesta impulsional** del canal $ h[n] $.\n\n$$\ny[n] = x[n] * h[n]\n$$\n\nDonde $ h[n] $, la respuesta impulsional, tiene la siguiente forma:\n\n$$\nh[n] = \\delta[n] + a_1 \\delta[n - d_1] + a_2 \\delta[n - d_2]\n$$\n\n- $ a_1 $: Atenuación del primer eco.\n- $ d_1 $: Retardo del primer eco.\n- $ a_2 $: Atenuación del segundo eco.\n- $ d_2 $: Retardo del segundo eco.\n\nEl primer termino representa la senal original, que pasa **sin retraso ni atenuacion**.\n\nEl segundo y tercer termino representan el primer y segundo eco, respectivamente. Con su atenuacion $ a $ y restardo o delay $ d $\n\nUn canal digital de dos ecos es estable en el sentido BIBO, ya que su respuesta impulsional es finita y absolutamente sumable. Un sistema FIR siempre es estable porque su respuesta impulsional es finita y no incluye retroalimentación (depende solo de los valores actuales y pasados de la entrada).\n\nEntonces, para modelar un sistema con el comportamiento de la respuesta impulsional dada, se requieren los valores de atenuacion y retardo de cada uno de los ecos.\n\nEl siguiente script lee el archivo CSV con la respuesta impulsional $ h[n] $, identifica los valores no nulos y obtiene las amplitudes y los retardos de cada uno de los ecos.\n\n::: {#0fc39f61 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\ndef load_hcanal(num_al, base_path=\"data/signals\"):\n    \"\"\"\n    Carga la respuesta impulsional del canal desde un archivo CSV.\n\n    Parámetros:\n        num_al (int): Número de alumno.\n        base_path (str): Directorio base donde están los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n    \"\"\"\n    # Determinar el número de caso (num_al % 5)\n    case_number = num_al % 5\n    print(f\"El número de caso seleccionado es: {case_number}\")\n\n    # Ruta del archivo\n    file_name = f\"case{case_number}_clean.csv\"\n    file_path = os.path.join(base_path, file_name)\n\n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n\n    # Cargar la señal desde el archivo\n    h = np.loadtxt(file_path, delimiter=\",\")\n    n = np.arange(len(h))\n\n    return n, h\n\ndef analyze_impulse_response(n, h):\n    \"\"\"\n    Analiza la respuesta impulsional y obtiene las amplitudes y retardos de los ecos.\n\n    Parámetros:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n\n    Retorna:\n        (a1, d1, a2, d2): Amplitudes y retardos de los dos ecos.\n    \"\"\"\n    # Encontrar los índices donde h[n] es no nulo\n    non_zero_indices = np.nonzero(h)[0]\n    non_zero_values = h[non_zero_indices]\n    \n    # Extraer valores\n    a0 = non_zero_values[0]  # Pico principal (valor unitario)\n    d0 = non_zero_indices[0]  # Pico principal\n    \n    a1 = non_zero_values[1]  # Amplitud del primer eco\n    d1 = non_zero_indices[1]  # Retardo del primer eco\n    \n    a2 = non_zero_values[2]  # Amplitud del segundo eco\n    d2 = non_zero_indices[2]  # Retardo del segundo eco\n    \n    print(\"Valores obtenidos de la respuesta impulsional:\")\n    print(f\"   Amplitud a1: {a1}, Retardo d1: {d1}\")\n    print(f\"   Amplitud a2: {a2}, Retardo d2: {d2}\")\n    \n    return a1, d1, a2, d2, non_zero_indices, non_zero_values\n\ndef plot_nonzero_impulse_response(n, h, a1, d1, a2, d2, indices, values):\n    \"\"\"\n    Grafica la respuesta impulsional mostrando solo los valores no nulos.\n\n    Parámetros:\n        n (numpy.ndarray): Instantes de tiempo.\n        h (numpy.ndarray): Respuesta impulsional del canal.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n        indices (list): Índices de los valores no nulos.\n        values (list): Valores de amplitud no nulos.\n    \"\"\"\n    plt.figure(figsize=(12, 5))\n    \n    # Graficar solo valores no nulos\n    plt.stem(indices, values, linefmt=\"b-\", markerfmt=\"bo\", basefmt=\" \")\n    \n    # Anotar los ecos detectados\n    plt.annotate(f\"Eco 1: a1={a1}, d1={d1}\", (d1, a1), textcoords=\"offset points\", xytext=(0,10), ha='center', color='red')\n    plt.annotate(f\"Eco 2: a2={a2}, d2={d2}\", (d2, a2), textcoords=\"offset points\", xytext=(0,10), ha='center', color='green')\n\n    # Configuración del gráfico\n    plt.title(\"Respuesta Impulsional del Canal (Solo Valores No Nulos)\")\n    plt.xlabel(\"n (instantes)\")\n    plt.ylabel(\"h[n] (amplitud)\")\n    plt.grid()\n    plt.show()\n\n# Parámetros\nnum_al = 14253  # Número de alumno\n\n# 1. Cargar la respuesta impulsional\nn, h = load_hcanal(num_al)\n\n# 2. Analizar la respuesta impulsional para obtener a1, d1, a2, d2\na1, d1, a2, d2, non_zero_indices, non_zero_values = analyze_impulse_response(n, h)\n\n# 3. Graficar solo los valores no nulos\nplot_nonzero_impulse_response(n, h, a1, d1, a2, d2, non_zero_indices, non_zero_values)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEl número de caso seleccionado es: 3\nValores obtenidos de la respuesta impulsional:\n   Amplitud a1: -0.45, Retardo d1: 8820\n   Amplitud a2: 0.2025, Retardo d2: 17640\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](01_h_system_files/figure-html/cell-3-output-2.png){width=1031 height=449}\n:::\n:::\n\n\nUna vez creado el sistema de eco, se toma la senal de audio del archivo `audio.wav`. Al mismo, se le aplica la funcion implementada para obtener una senal de salida $ y[n] $.\n\nEl sistema esta dado por el doble eco:\n\n- $ a1 = -0.45 $, retardo $ d1 = 8820 $.\n- $ a2 = 0.2025 $, retardo $ d2 = 17640 $.\n- \nFinalmente, se grafican la entrada y la salida del sistema.\n\n::: {#d860026a .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.io import wavfile\n\n# 1. Función del sistema: Canal de doble eco\ndef double_echo_system(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica un canal de doble eco a la señal de entrada.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n\n    Retorna:\n        y (numpy.ndarray): Señal de salida con el canal de doble eco aplicado.\n    \"\"\"\n    N = len(x)  # Longitud de la señal de entrada\n    y = np.zeros(N + d2)  # Crear salida con espacio suficiente para los retardos\n    \n    # Componente principal (sin retraso)\n    y[:N] += x\n    \n    # Primer eco\n    y[d1:N + d1] += a1 * x\n    \n    # Segundo eco\n    y[d2:N + d2] += a2 * x\n    \n    return y\n\n# 2. Cargar el archivo de audio\ndef load_audio(file_path):\n    \"\"\"\n    Carga una señal de audio y la convierte a mono si es estéreo.\n\n    Parámetros:\n        file_path (str): Ruta del archivo de audio.\n\n    Retorna:\n        fs (int): Frecuencia de muestreo.\n        x (numpy.ndarray): Señal de audio en mono.\n    \"\"\"\n    fs, x = wavfile.read(file_path)  # Cargar archivo de audio\n    \n    # Si la señal es estéreo, convertir a mono\n    if len(x.shape) > 1:\n        print(\"La señal es estéreo. Convirtiendo a mono...\")\n        x = np.mean(x, axis=1)  # Promedio de canales\n    \n    x = x.astype(float)  # Convertir a tipo float\n    return fs, x\n\n# 3. Graficar señales\ndef plot_input_output(x, y, fs):\n    \"\"\"\n    Grafica la señal de entrada y salida.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        y (numpy.ndarray): Señal de salida.\n        fs (int): Frecuencia de muestreo.\n    \"\"\"\n    t_x = np.arange(len(x)) / fs  # Eje temporal de la señal de entrada\n    t_y = np.arange(len(y)) / fs  # Eje temporal de la señal de salida\n\n    plt.figure(figsize=(12, 6))\n\n    # Señal de entrada\n    plt.subplot(2, 1, 1)\n    plt.plot(t_x, x, color='b')\n    plt.title(\"Señal de Entrada x[n]\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Señal de salida\n    plt.subplot(2, 1, 2)\n    plt.plot(t_y, y, color='g')\n    plt.title(\"Señal de Salida y[n] (Canal de Doble Eco Aplicado)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    plt.tight_layout()\n    plt.show()\n\n# -----------------------------------------------\n# Parámetros\naudio_input = \"data/audio.wav\"  # Ruta del archivo de audio\na1, d1 = -0.45, 8820            # Amplitud y retardo del primer eco\na2, d2 = 0.2025, 17640          # Amplitud y retardo del segundo eco\n\n# 1. Cargar la señal de entrada\nfs, x = load_audio(audio_input)\nprint(f\"Frecuencia de muestreo: {fs} Hz\")\nprint(f\"Longitud de la señal de entrada: {len(x)} muestras\")\n\n# 2. Aplicar el sistema de doble eco\ny = double_echo_system(x, a1, d1, a2, d2)\nprint(f\"Longitud de la señal de salida: {len(y)} muestras\")\n\n# 3. Graficar las señales\nplot_input_output(x, y, fs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLa señal es estéreo. Convirtiendo a mono...\nFrecuencia de muestreo: 48000 Hz\nLongitud de la señal de entrada: 47668 muestras\nLongitud de la señal de salida: 65308 muestras\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](01_h_system_files/figure-html/cell-4-output-2.png){width=1142 height=566}\n:::\n:::\n\n\n::: {#d4724c28 .cell execution_count=4}\n``` {.python .cell-code}\nimport sounddevice as sd\n\ndef play_audio(signal, fs, description):\n    \"\"\"\n    Reproduce una señal de audio.\n\n    Parámetros:\n        signal (numpy.ndarray): Señal de audio.\n        fs (int): Frecuencia de muestreo.\n        description (str): Descripción de la señal para la consola.\n    \"\"\"\n    print(f\"Reproduciendo: {description}...\")\n    sd.play(signal, samplerate=fs)\n    sd.wait()  # Esperar hasta que termine la reproducción\n    print(f\"Reproducción de {description} completada.\\n\")\n\n# 1. Reproducir la señal de entrada\nplay_audio(x, fs, \"Señal de Entrada x[n]\")\n\n# 2. Reproducir la señal de salida\nplay_audio(y, fs, \"Señal de Salida y[n] (Canal de Doble Eco Aplicado)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReproduciendo: Señal de Entrada x[n]...\nReproducción de Señal de Entrada x[n] completada.\n\nReproduciendo: Señal de Salida y[n] (Canal de Doble Eco Aplicado)...\nReproducción de Señal de Salida y[n] (Canal de Doble Eco Aplicado) completada.\n\n```\n:::\n:::\n\n\nSe observa claramente la senal de entrada y la senal de salida con los dos ecos atenuados.\n\nPara compensar los ecos y que la senal filtrada sea lo mas cercana posible a la senal original, se implementara un filtro FIR que corrija la respuesta impulsional $ h[n] $ del canal de ecos.\n\nLa idea de implementar un **sistema corrector FIR** en **cascada** con el filtro de doble canal, es aproximar la **respuesta impulsional total** del sistema resultante a una **unica delta de Kronecker**\n\nSi la respuesta impulsional total se aproxima a una delta, significa que el sistema (canal + filtro) no introduce distorsion ni retardos en la senal de entrada.\n\nEl filtro corrige el canal al cancelar los ecos con retardos y atenuaciones opuestos al filtro original. \n\n::: {#7dc05068 .cell execution_count=5}\n``` {.python .cell-code}\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.io import wavfile\n\n# 1. Función del sistema: Canal de doble eco\ndef double_echo_system(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica un canal de doble eco a la señal de entrada.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        a1 (float): Amplitud del primer eco.\n        d1 (int): Retardo del primer eco.\n        a2 (float): Amplitud del segundo eco.\n        d2 (int): Retardo del segundo eco.\n\n    Retorna:\n        y (numpy.ndarray): Señal de salida con el canal de doble eco aplicado.\n    \"\"\"\n    N = len(x)  # Longitud de la señal de entrada\n    y = np.zeros(N + d2)  # Crear salida con espacio suficiente para los retardos\n    \n    # Componente principal (sin retraso)\n    y[:N] += x\n    \n    # Primer eco\n    y[d1:N + d1] += a1 * x\n    \n    # Segundo eco\n    y[d2:N + d2] += a2 * x\n    \n    return y / np.max(np.abs(y))  # Normalizar para evitar desbordamiento\n\n# 2. Corregir la señal con un filtro de 1 rama de retardo\ndef correct_signal_1r(x, a1, d1):\n    \"\"\"\n    Aplica una corrección de 1 rama de retardo a la señal de entrada.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        a1 (float): Amplitud de la primera corrección.\n        d1 (int): Retardo de la primera corrección.\n\n    Retorna:\n        y (numpy.ndarray): Señal corregida.\n    \"\"\"\n    y = x.copy()\n    y[d1:] -= a1 * y[:-d1]  # Corregir el eco\n    return y\n\n# 3. Corregir la señal con un filtro de 2 ramas de retardo\ndef correct_signal_2r(x, a1, d1, a2, d2):\n    \"\"\"\n    Aplica una corrección de 2 ramas de retardo a la señal de entrada.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        a1 (float): Amplitud de la primera corrección.\n        d1 (int): Retardo de la primera corrección.\n        a2 (float): Amplitud de la segunda corrección.\n        d2 (int): Retardo de la segunda corrección.\n\n    Retorna:\n        y (numpy.ndarray): Señal corregida.\n    \"\"\"\n    y = x.copy()\n    y[d1:] -= a1 * y[:-d1]  # Corregir primer eco\n    y[d2:] -= a2 * y[:-d2]  # Corregir segundo eco\n    return y\n\n# 4. Cargar el archivo de audio\ndef load_audio(file_path):\n    \"\"\"\n    Carga una señal de audio y la convierte a mono si es estéreo.\n\n    Parámetros:\n        file_path (str): Ruta del archivo de audio.\n\n    Retorna:\n        fs (int): Frecuencia de muestreo.\n        x (numpy.ndarray): Señal de audio en mono.\n    \"\"\"\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n    \n    fs, x = wavfile.read(file_path)  # Cargar archivo de audio\n    \n    # Si la señal es estéreo, convertir a mono\n    if len(x.shape) > 1:\n        print(\"La señal es estéreo. Convirtiendo a mono...\")\n        x = np.mean(x, axis=1)  # Promedio de canales\n    \n    x = x.astype(float)  # Convertir a tipo float\n    return fs, x\n\n# 5. Graficar señales\ndef plot_signals(x, y_echo, y_corr1, y_corr2, fs):\n    \"\"\"\n    Grafica las señales de entrada, con ecos y las corregidas.\n\n    Parámetros:\n        x (numpy.ndarray): Señal de entrada.\n        y_echo (numpy.ndarray): Señal con ecos.\n        y_corr1 (numpy.ndarray): Señal corregida (1 rama de retardo).\n        y_corr2 (numpy.ndarray): Señal corregida (2 ramas de retardo).\n        fs (int): Frecuencia de muestreo.\n    \"\"\"\n    t_x = np.arange(len(x)) / fs  # Eje temporal de la señal de entrada\n    t_y = np.arange(len(y_echo)) / fs  # Eje temporal de las señales de salida\n\n    plt.figure(figsize=(12, 12))\n\n    # Señal de entrada original\n    plt.subplot(4, 1, 1)\n    plt.plot(t_x, x, color='b')\n    plt.title(\"Señal Original x[n]\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Señal con ecos\n    plt.subplot(4, 1, 2)\n    plt.plot(t_y, y_echo, color='g')\n    plt.title(\"Señal con Ecos y[n] (Canal de Doble Eco)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Señal corregida con 1 rama de retardo\n    plt.subplot(4, 1, 3)\n    plt.plot(t_y, y_corr1, color='r')\n    plt.title(\"Señal Corregida (Filtro con 1 Rama de Retardo)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    # Señal corregida con 2 ramas de retardo\n    plt.subplot(4, 1, 4)\n    plt.plot(t_y, y_corr2, color='m')\n    plt.title(\"Señal Corregida (Filtro con 2 Ramas de Retardo)\")\n    plt.xlabel(\"Tiempo [s]\")\n    plt.ylabel(\"Amplitud\")\n    plt.grid()\n\n    plt.tight_layout()\n    plt.show()\n\n# -----------------------------------------------\n# Parámetros\naudio_input = \"data/audio.wav\"  # Ruta del archivo de audio\na1, d1 = -0.45, 8820            # Amplitud y retardo del primer eco\na2, d2 = 0.2025, 17640          # Amplitud y retardo del segundo eco\n\n# 1. Cargar la señal de entrada\nfs, x = load_audio(audio_input)\nprint(f\"Frecuencia de muestreo: {fs} Hz\")\nprint(f\"Longitud de la señal de entrada: {len(x)} muestras\")\n\n# 2. Aplicar el sistema de doble eco\ny_echo = double_echo_system(x, a1, d1, a2, d2)\n\n# 3. Corregir la señal\ny_corr1 = correct_signal_1r(y_echo, a1, d1)\ny_corr2 = correct_signal_2r(y_echo, a1, d1, a2, d2)\n\n# 4. Graficar todas las señales\nplot_signals(x, y_echo, y_corr1, y_corr2, fs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLa señal es estéreo. Convirtiendo a mono...\nFrecuencia de muestreo: 48000 Hz\nLongitud de la señal de entrada: 47668 muestras\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](01_h_system_files/figure-html/cell-6-output-2.png){width=1142 height=1143}\n:::\n:::\n\n\n",
    "supporting": [
      "01_h_system_files"
    ],
    "filters": [],
    "includes": {}
  }
}