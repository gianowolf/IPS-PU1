{
  "hash": "63e083fa3467673ee5749cd835a3245e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Carga senal de entrada $ x[n] $\njupyter: python3\n---\n\n\n\n\n\nComo se realizó anteriormente, se selecciona una senal de entrada en base al numero de alumno, mediante la función `load_signal`\n\n::: {#e1f632a6 .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función para cargar la señal desde el archivo CSV\ndef load_signal(case_number, base_path=\"data/signals\"):\n    \"\"\"\n    Carga una señal desde un archivo CSV según el número de caso.\n\n    Parámetros:\n        case_number (int): Número de caso (0, 1, 2, 3).\n        base_path (str): Ruta base donde se encuentran los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes n (0 hasta longitud de la señal - 1).\n        x (numpy.ndarray): Valores de la señal x[n].\n    \"\"\"\n    # Construir la ruta del archivo CSV\n    file_path = os.path.join(base_path, f\"case{case_number}.csv\")\n    \n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n    \n    # Cargar los valores de la señal desde el archivo CSV\n    x = np.loadtxt(file_path, delimiter=\",\")\n    \n    # Generar los instantes n (0, 1, ..., len(x)-1)\n    n = np.arange(len(x))\n    \n    return n, x\n```\n:::\n\n\n## Se definen los sistemas\n\nSe definen los sistemas como funciones.\n\n- N es la longitud de la senal de entrada.\n- se inicializa la salida y con ceros.\n- se realiza una convolucion de forma iterativa\n\n::: {#1f4f2dde .cell execution_count=2}\n``` {.python .cell-code}\n# Definir las implementaciones de los sistemas (previamente implementados)\ndef sistema1(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.5 * x[n]\n        if n > 0:\n            y[n] += 0.5 * x[n-1]\n    return y\n\ndef sistema2(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.5 * x[n]\n        if n > 0:\n            y[n] -= 0.5 * x[n-1]\n    return y\n\ndef sistema3(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.25 * x[n]\n        if n > 0:\n            y[n] += 0.25 * x[n-1]\n            y[n] += 0.5 * y[n-1]\n    return y\n\ndef sistema4(x):\n    N = len(x)\n    y = np.zeros(N)\n    for n in range(N):\n        y[n] = 0.25 * x[n]\n        if n > 0:\n            y[n] -= 0.25 * x[n-1]\n            y[n] -= 0.5 * y[n-1]\n    return y\n```\n:::\n\n\n## Se aplica la entrada al sistema\n\nSe aplica la entrada $ x[n] $ en cada uno de los sistemas, y se grafican\n\n::: {#a4be2193 .cell execution_count=3}\n``` {.python .cell-code}\n# Número de alumno y selección de caso\nnum_al = 14253  # Número de alumno\ncase_number = num_al % 4  # Determinar el número de caso\nprint(f\"El número de caso seleccionado es: {case_number}\")\n\n# Cargar la señal correspondiente\nn, x = load_signal(case_number)\n\n# Aplicar los sistemas a la señal de entrada\ny1 = sistema1(x)\ny2 = sistema2(x)\ny3 = sistema3(x)\ny4 = sistema4(x)\n\n# Graficar las señales de salida\nplt.figure(figsize=(12, 10))\n\n# Señal de entrada\nplt.subplot(5, 1, 1)\nplt.stem(n, x, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(f\"Señal de Entrada x[n] - Caso {case_number} para Número de Alumno {num_al}\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"x[n]\")\nplt.grid()\n\n# Salida del Sistema 1\nplt.subplot(5, 1, 2)\nplt.stem(n, y1, basefmt=\" \", linefmt=\"g-\", markerfmt=\"go\")\nplt.title(\"Salida del Sistema 1\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y1[n]\")\nplt.grid()\n\n# Salida del Sistema 2\nplt.subplot(5, 1, 3)\nplt.stem(n, y2, basefmt=\" \", linefmt=\"r-\", markerfmt=\"ro\")\nplt.title(\"Salida del Sistema 2\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y2[n]\")\nplt.grid()\n\n# Salida del Sistema 3\nplt.subplot(5, 1, 4)\nplt.stem(n, y3, basefmt=\" \", linefmt=\"c-\", markerfmt=\"co\")\nplt.title(\"Salida del Sistema 3\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y3[n]\")\nplt.grid()\n\n# Salida del Sistema 4\nplt.subplot(5, 1, 5)\nplt.stem(n, y4, basefmt=\" \", linefmt=\"m-\", markerfmt=\"mo\")\nplt.title(\"Salida del Sistema 4\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"y4[n]\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEl número de caso seleccionado es: 1\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](04_y_output_files/figure-html/cell-4-output-2.png){width=1142 height=950}\n:::\n:::\n\n\n### Conclusiones de las salidas \n\n#### Sistema 1\n\nEl Sistema 1 es un **filtro pasa bajas**, de **promedio movil** de orden 1.\n\nLa salida obtenida **suaviza** la señal de entrada. Se observa el patron de crecimiento de la señal de entrada, pero **menos oscilante**. Esto se debe a que el valor de $ y[n] $ es el promedio ponderado de x[n] y x[n-1], lo cual atenua frecuencias altas.\n\n#### Sistema 2\n\nEl Sistema 2 es un **filtro pasa altas**. La salida resalta los cambios bruscos de la senal de entrada. Aqui destaca la baja amplitud de la salida, en comparacion con los valores de entrada. Esto se debe a la diferencia entre valores consecutivos de $ x[n] $.\n\n#### Sistema 3\n\nEl Sistema 3 es un **filtro pasa bajas** recursivo (con termino de retroalimentacion). Al igual que el Sistema 1, suaviza la senal de entrada.\n\n#### Sistema 4\n\nEl Sistema 4 es un **filtro pasa altas** recursivo, con retroalimentacion negativa. Amplifica los cambios rapidos e introduce el efecto de alternancia.\n\n## Se obtiene la TFTD de las salidas\n\nPara realizar un analisis del comportamiento de las frecuencias al aplicar los distintos sistemas, se aplica la TFTD a las salidas.\n\n::: {#ef562baa .cell execution_count=4}\n``` {.python .cell-code}\n# Calcular la TFTD de la señal de entrada x[n]\nfft_x = np.fft.fft(x, n=512)  # FFT con cero-padding hasta 512 puntos\nfft_x_shifted = np.fft.fftshift(fft_x)  # Desplazar para centrar en ω = 0\n\n# Calcular la TFTD de las salidas\nfft_y1 = np.fft.fft(y1, n=512)\nfft_y2 = np.fft.fft(y2, n=512)\nfft_y3 = np.fft.fft(y3, n=512)\nfft_y4 = np.fft.fft(y4, n=512)\n\n# Frecuencias normalizadas\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Rango de -π a π\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Desplazar las FFT para centrar en ω = 0\nfft_y1_shifted = np.fft.fftshift(fft_y1)\nfft_y2_shifted = np.fft.fftshift(fft_y2)\nfft_y3_shifted = np.fft.fftshift(fft_y3)\nfft_y4_shifted = np.fft.fftshift(fft_y4)\n\n# Graficar las respuestas en frecuencia\nplt.figure(figsize=(12, 12))\n\n# Magnitud de la TFTD - Señal de Entrada\nplt.subplot(5, 1, 1)\nplt.plot(frequencies_shifted, np.abs(fft_x_shifted), color='k')\nplt.title(\"TFTD: Magnitud de la Señal de Entrada $x[n]$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|X(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 1\nplt.subplot(5, 1, 2)\nplt.plot(frequencies_shifted, np.abs(fft_y1_shifted), color='b')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 1\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_1(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 2\nplt.subplot(5, 1, 3)\nplt.plot(frequencies_shifted, np.abs(fft_y2_shifted), color='g')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 2\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_2(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 3\nplt.subplot(5, 1, 4)\nplt.plot(frequencies_shifted, np.abs(fft_y3_shifted), color='r')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 3\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_3(e^{j\\omega})|$\")\nplt.grid()\n\n# Magnitud de la TFTD - Sistema 4\nplt.subplot(5, 1, 5)\nplt.plot(frequencies_shifted, np.abs(fft_y4_shifted), color='m')\nplt.title(\"TFTD: Magnitud de la Salida - Sistema 4\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|Y_4(e^{j\\omega})|$\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](04_y_output_files/figure-html/cell-5-output-1.png){width=1143 height=1141}\n:::\n:::\n\n\nEl primer grafico muestra el modulo de la TFTD de la senal de entrada $ x[n] $. Se observa un pico predominante en bajas frecuencias (cerca de $ \\omega = 0 $), lo cual indica que la senal tiene componentes de baja frecuencia elevadas.\n\nAdemas, se notan **componentes de alta frecuencia** cerca de $ \\pm \\pi $. Aunque la magnitud de estas frecuencias es mucho menor a las cercanas a cero, se observa un crecimiento notorio a medida que las frecuencias aumentan.\n\nLos Sistemas 1 y 3, mantienen el **pico centrado en $ \\omega = 0 $** similar a la senal de entrada. Y en contraste con esta, las frecuencias altas han sido **atenuadas**, como se espera en filtros pasa bajos.\n\nLos Sistemas 2 y 4, en cambio, funcionan como **filtros pasa altos** y se observa que las **frecuencias bajas**, predominantes en la senal de entrada, se encuentran **atenuadas** casi por completo, y mantiene las frecuencias altas, que se pueden apreciar mejor en estos graficos debido al reescalado del eje de magnitud. \n\n",
    "supporting": [
      "04_y_output_files"
    ],
    "filters": [],
    "includes": {}
  }
}