{
  "hash": "e83c5f9dffeb6f5fc050905594f941e5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Sistemas: resolucion numerica'\njupyter: python3\n---\n\n\n\n## Librerias \n\nPara implementar los sistemas discretos, calcular la **respuesta impulsional** y aplicar la **Transformada de Fourier en Tiempo Discreto (TFTD)**, se utilizan las siguientes librerías y funciones de **Python**:\n\n- **NumPy** es fundamental para realizar cálculos numéricos en Python.  \n- **Matplotlib** se utiliza para **graficar** los resultados obtenidos. Permite visualizar tanto señales en el **dominio del tiempo** como en el **dominio de la frecuencia**.    \n\n- `np.zeros(N)`: Crea un arreglo de ceros con $ N $ elementos.  \n- `np.arange(start, stop)`: Crea una secuencia de números entre `start` y `stop`.  \n- `np.convolve(x, h, mode)`: Realiza la convolución entre dos señales.  \n- `np.fft.fft(h)`: Calcula la **Transformada de Fourier** de la señal $ h $.  \n- `np.fft.fftfreq(N, d)`: Devuelve las frecuencias correspondientes a la FFT.  \n\n- `plt.stem(x, y)`: Grafica una señal **discreta**.  \n- `plt.plot(x, y)`: Grafica una señal **continua** o en el dominio de la frecuencia.  \n- `plt.title()`, `plt.xlabel()`, `plt.ylabel()`: Añaden títulos y etiquetas a los gráficos.  \n- `plt.grid()`: Activa la cuadrícula en el gráfico.\n\nSe utilizan funciones personalizadas para implementar cada uno de los sistemas en forma de **convolución**. Cada sistema será una función que recibirá una señal de entrada $ x[n] $ y devolverá la señal de salida $ y[n] $.\n\n**Método**:  \n- La respuesta de cada sistema se obtiene utilizando la **convolución** entre la entrada $ x[n] $ y la **respuesta impulsional** $ h[n] $.  \n- Se aplicará la **TFTD** (mediante `np.fft.fft`) a la respuesta impulsional para verificar que coincide con la respuesta en frecuencia analítica.\n\n\n## Sistema 1\n\n::: {#5fe88229 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función que implementa el Sistema 1\ndef sistema1(x):\n    \"\"\"\n    Implementa el sistema 1: y[n] = 0.5*x[n] + 0.5*x[n-1]\n    Entrada: x -> Señal de entrada\n    Salida: y -> Señal de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.5 * x[n]  # Primer término\n        if n > 0:\n            y[n] += 0.5 * x[n-1]  # Segundo término (desplazado)\n    return y\n\n# Generar la señal de entrada: impulso unitario δ[n]\nN = 20  # Duración de la señal\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema1(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos para mayor resolución\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre -π y π\nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en ω = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 1\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia ∠H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](03_h_systems_num_files/figure-html/cell-2-output-1.png){width=1143 height=756}\n:::\n:::\n\n\n## Sistema 2\n\n::: {#5a5d3158 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función que implementa el Sistema 2\ndef sistema2(x):\n    \"\"\"\n    Implementa el sistema 2: y[n] = 0.5*x[n] - 0.5*x[n-1]\n    Entrada: x -> Señal de entrada\n    Salida: y -> Señal de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.5 * x[n]  # Primer término\n        if n > 0:\n            y[n] -= 0.5 * x[n-1]  # Segundo término (desplazado y restado)\n    return y\n\n# Generar la señal de entrada: impulso unitario δ[n]\nN = 20  # Duración de la señal\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema2(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre -π y π\nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en ω = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 2\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia ∠H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](03_h_systems_num_files/figure-html/cell-3-output-1.png){width=1141 height=756}\n:::\n:::\n\n\n## Sistema 3\n\n::: {#ff8550d8 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función que implementa el Sistema 3\ndef sistema3(x):\n    \"\"\"\n    Implementa el sistema 3: y[n] = 0.25*x[n] + 0.25*x[n-1] + 0.5*y[n-1]\n    Entrada: x -> Señal de entrada\n    Salida: y -> Señal de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.25 * x[n]  # Primer término\n        if n > 0:\n            y[n] += 0.25 * x[n-1]  # Segundo término (desplazado)\n            y[n] += 0.5 * y[n-1]   # Término recursivo\n    return y\n\n# Generar la señal de entrada: impulso unitario δ[n]\nN = 20  # Duración de la señal\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema3(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre -π y π\nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en ω = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 3\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia ∠H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](03_h_systems_num_files/figure-html/cell-4-output-1.png){width=1143 height=756}\n:::\n:::\n\n\n::: {#86587bef .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Función que implementa el Sistema 4\ndef sistema4(x):\n    \"\"\"\n    Implementa el sistema 4: y[n] = 0.25*x[n] - 0.25*x[n-1] - 0.5*y[n-1]\n    Entrada: x -> Señal de entrada\n    Salida: y -> Señal de salida\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)  # Inicializa la salida con ceros\n    for n in range(N):\n        y[n] = 0.25 * x[n]  # Primer término\n        if n > 0:\n            y[n] -= 0.25 * x[n-1]  # Segundo término (desplazado y restado)\n            y[n] -= 0.5 * y[n-1]   # Término recursivo (negativo)\n    return y\n\n# Generar la señal de entrada: impulso unitario δ[n]\nN = 20  # Duración de la señal\ndelta = np.zeros(N)\ndelta[0] = 1  # Impulso en n = 0\n\n# Calcular la respuesta impulsional h[n]\nh = sistema4(delta)\n\n# Calcular la Transformada de Fourier (FFT) de h[n]\nH = np.fft.fft(h, n=512)  # FFT con 512 puntos\nfrequencies = np.fft.fftfreq(512, d=1) * 2 * np.pi  # Frecuencias normalizadas entre -π y π\nH_shifted = np.fft.fftshift(H)  # Centrar la FFT en ω = 0\nfrequencies_shifted = np.fft.fftshift(frequencies)\n\n# Calcular la magnitud y la fase\nmagnitude = np.abs(H_shifted)\nphase = np.angle(H_shifted)\n\n# Graficar los resultados\nplt.figure(figsize=(12, 8))\n\n# Respuesta impulsional h[n]\nplt.subplot(3, 1, 1)\nplt.stem(range(N), h, basefmt=\" \", linefmt=\"b-\", markerfmt=\"bo\")\nplt.title(\"Respuesta Impulsional $h[n]$ - Sistema 4\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(r\"$h[n]$\")\nplt.grid()\n\n# Magnitud de la respuesta en frecuencia |H(e^jw)|\nplt.subplot(3, 1, 2)\nplt.plot(frequencies_shifted, magnitude, color='b')\nplt.title(r\"Magnitud de la Respuesta en Frecuencia $|H(e^{j\\omega})|$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$|H(e^{j\\omega})|$\")\nplt.grid()\n\n# Fase de la respuesta en frecuencia ∠H(e^jw)\nplt.subplot(3, 1, 3)\nplt.plot(frequencies_shifted, phase, color='r')\nplt.title(r\"Fase de la Respuesta en Frecuencia $\\angle H(e^{j\\omega})$\")\nplt.xlabel(r\"Frecuencia Normalizada $\\omega$ (radianes/muestra)\")\nplt.ylabel(r\"$\\angle H(e^{j\\omega})$ (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](03_h_systems_num_files/figure-html/cell-5-output-1.png){width=1141 height=756}\n:::\n:::\n\n\n",
    "supporting": [
      "03_h_systems_num_files"
    ],
    "filters": [],
    "includes": {}
  }
}