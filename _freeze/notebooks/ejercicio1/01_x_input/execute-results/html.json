{
  "hash": "b2ee86905a366844057496559226fdbb",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: '**1.1 Señal Discreta**'\njupyter: python3\n---\n\n\n\n\n\nEn esta sección, se genera la señal discreta $ x[n] $, se grafica y analiza sus componentes de frecuencia mediante la Transformada de Fourier Discreta (TFTD).\n\n### Librerias\n\nSe utilizan las librerías  `numpy`, `matplotlib` y `scipy` para resolver este ejercicio. Todas se encuentran explicadas en la seccion de `librerias`.\n\n::: {#f0e9acad .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, fftshift\n```\n:::\n\n\n### Entrada\n\nSe genera la señal de entrada basada en el número de alumno. En este caso 01425/3, por lo tanto 14.253. \n\n::: {#9d5b0780 .cell execution_count=2}\n``` {.python .cell-code}\nnum_al = 14253 # Num de alumno\n```\n:::\n\n\nLas señales se encuentran en formato CSV en el directorio ```data/signals```. \n\nPara cargar la señal de CSV, se utiliza el script ```load_signal```\n\n::: {#af8b3da4 .cell execution_count=3}\n``` {.python .cell-code}\ndef load_signal(case_number, base_path=\"data/signals\"):\n    \"\"\"\n    Carga una señal desde un archivo CSV según el número de caso.\n\n    Parámetros:\n        case_number (int): Número de caso (0, 1, 2, 3).\n        base_path (str): Ruta base donde se encuentran los archivos CSV.\n\n    Retorna:\n        n (numpy.ndarray): Instantes n (0 hasta longitud de la señal - 1).\n        x (numpy.ndarray): Valores de la señal x[n].\n    \"\"\"\n    # Construir la ruta del archivo CSV\n    file_path = os.path.join(base_path, f\"case{case_number}.csv\")\n    \n    # Verificar si el archivo existe\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"El archivo {file_path} no existe.\")\n    \n    # Cargar los valores de la señal desde el archivo CSV\n    x = np.loadtxt(file_path, delimiter=\",\")\n    \n    # Generar los instantes n (0, 1, ..., len(x)-1)\n    n = np.arange(len(x))\n    \n    return n, x\n```\n:::\n\n\nSe cargan las señales\n\n::: {#f6707a06 .cell execution_count=4}\n``` {.python .cell-code}\nn0, x0 = load_signal(0)  # Caso 0\nn1, x1 = load_signal(1)  # Caso 1\nn2, x2 = load_signal(2)  # Caso 2\nn3, x3 = load_signal(3)  # Caso 3\n```\n:::\n\n\nSe grafican las señales de entrada\n\n::: {#cf44768e .cell execution_count=5}\n``` {.python .cell-code}\n# Crear una figura con subplots para las cuatro señales\nfig, axs = plt.subplots(2, 2, figsize=(12, 8))\n\n# Graficar Caso 0\naxs[0, 0].stem(n0, x0)\naxs[0, 0].set_title(\"Caso 0\")\naxs[0, 0].set_xlabel(\"n\")\naxs[0, 0].set_ylabel(\"x[n]\")\naxs[0, 0].grid()\n\n# Graficar Caso 1\naxs[0, 1].stem(n1, x1)\naxs[0, 1].set_title(\"Caso 1\")\naxs[0, 1].set_xlabel(\"n\")\naxs[0, 1].set_ylabel(\"x[n]\")\naxs[0, 1].grid()\n\n# Graficar Caso 2\naxs[1, 0].stem(n2, x2)\naxs[1, 0].set_title(\"Caso 2\")\naxs[1, 0].set_xlabel(\"n\")\naxs[1, 0].set_ylabel(\"x[n]\")\naxs[1, 0].grid()\n\n# Graficar Caso 3\naxs[1, 1].stem(n3, x3)\naxs[1, 1].set_title(\"Caso 3\")\naxs[1, 1].set_xlabel(\"n\")\naxs[1, 1].set_ylabel(\"x[n]\")\naxs[1, 1].grid()\n\n# Ajustar el diseño\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](01_x_input_files/figure-html/cell-6-output-1.png){width=1142 height=758}\n:::\n:::\n\n\nSe selecciona la señal designada, basada en el número de alumno\n\n::: {#78ace4ba .cell execution_count=6}\n``` {.python .cell-code}\ncase_number = num_al % 4\nprint(f\"El número de caso seleccionado es: {case_number}\")\n\n# Cargar la señal correspondiente\nn, x = load_signal(case_number)\n\n# Graficar la señal seleccionada\nplt.figure(figsize=(10, 5))\nplt.stem(n, x)\nplt.title(f\"Señal Correspondiente al Caso {case_number} para Número de Alumno {num_al}\")\nplt.xlabel(\"n (instantes)\")\nplt.ylabel(\"x[n] (amplitud)\")\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEl número de caso seleccionado es: 1\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](01_x_input_files/figure-html/cell-7-output-2.png){width=812 height=450}\n:::\n:::\n\n\n### Análisis de Datos\n\nLa señal de entrada debe procesarse mediante la **Transformada de Fourier Discreta** (TFTD o DFT) permite transformar una señal discreta en el dominio del tiempo  en una representación en el **dominio de la frecuencia** \n\n$$ x[n] \\xrightarrow{F} X[k] $$\n\nDonde la transformada está dada por:\n\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-j2\\pi kn / N}, \\quad k = 0, 1, \\dots, N-1\n$$\n\nLa **Transformada Rápida de Fourier** (FFT) es una implementación eficiente de la DFT.\n\nMediante la librería Scipy se importan las funciones de FFT. Por defecto, cuando se calcula la FFT con ```fft``` las frecuencias bajas se encuentran al comienzo del array de salida, seguidas por las frecuencias positivas y finalmente las negativas. Esto se conoce como **orden natural**\n\nLa salida de la ```fft``` de Scipy es un **array de números complejos**. El orden de las frecuencias de salida comienza con los valores positivos, desde cero hasta la **Frecuencia de Nyquist**.\n\nPor su parte ```fftfreq``` permite asociar los índices de los espectros de frecuencia con su valor real en Hz. Es decir, asocia una frecuencia a cada componente de la FFT. La salida respeta el mismo orden que la ```fft``` normal.\n\nFinalmente, la función ```fftshift``` reorganiza este resultado para que las frecuencias aparezcan ordenadas de menor a mayor, lo que resulta de utilidad al momento de graficar los espectros.\n\n```py\n# Calcular FFT\nsignal_fft = fft(signal) \n\n# Obtener frecuencias\nfrequencies = fftfreq(N, d=T) \n\n# Aplicar fftshift para centrar el espectro\nfft_signal_shifted = fftshift(fft_signal)\nfrequencies_shifted = fftshift(frequencies)\n```\n  \nEn el caso del ejercicio a resolver:\n\n::: {#26370af9 .cell execution_count=7}\n``` {.python .cell-code}\n# Numero de muestras\nN = len(x)\nFs = 1000  # Frecuencia de muestreo (Hz)\n\n# Calcular la FFT\nX = fft(x)\n\n# Calcular las frecuencias\nfrequencies = fftfreq(N, d=1/Fs)\n\n# Centrar la FFT y las frecuencias\nfft_output_shifted = fftshift(X)\nfrequencies_shifted = fftshift(frequencies)\n\n# Calcular magnitud y fase\nmagnitude = np.abs(fft_output_shifted)\nphase = np.angle(fft_output_shifted)\n```\n:::\n\n\nSe realiza el gráfico correspo ndiente de la magnitud y fase de la TFTD generada\n\n::: {#d73be485 .cell execution_count=8}\n``` {.python .cell-code}\nplt.figure(figsize=(12, 6))\n\nplt.subplot(2, 1, 1)\nplt.stem(frequencies_shifted, magnitude, basefmt=\" \")\nplt.title(\"Espectro de Magnitud (Discreto)\")\nplt.xlabel(\"Frecuencia (Hz)\")\nplt.ylabel(\"Magnitud\")\nplt.grid()\n\n# Graficar espectro de fase de forma discreta\nplt.subplot(2, 1, 2)\nplt.stem(frequencies_shifted, phase, basefmt=\" \")\nplt.title(\"Espectro de Fase (Discreto)\")\nplt.xlabel(\"Frecuencia (Hz)\")\nplt.ylabel(\"Fase (radianes)\")\nplt.grid()\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](01_x_input_files/figure-html/cell-9-output-1.png){width=1142 height=566}\n:::\n:::\n\n\n## Sistemas Discretos\n\nSe dan sistemas están definidos por las siguientes **ecuaciones en diferencias**:\n\n1. Sistema 1:  \n   $$\n   y[n] = \\frac{1}{2}x[n] + \\frac{1}{2}x[n-1]\n   $$\n\n2. Sistema 2:  \n   $$\n   y[n] = \\frac{1}{2}x[n] - \\frac{1}{2}x[n-1]\n   \n   $$\n\n3. Sistema 3:  \n   $$\n   y[n] = \\frac{1}{4}x[n] + \\frac{1}{4}x[n-1] + \\frac{1}{2}y[n-1]\n   $$\n\n4. Sistema 4:  \n   $$\n   y[n] = \\frac{1}{4}x[n] - \\frac{1}{4}x[n-1] - \\frac{1}{2}y[n-1]\n   $$\n\n",
    "supporting": [
      "01_x_input_files"
    ],
    "filters": [],
    "includes": {}
  }
}